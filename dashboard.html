<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Work Item Analytics Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        // Ensure Chart.js defaults don't disable tooltips
        if (typeof Chart !== 'undefined') {
            Chart.defaults.plugins.tooltip = Chart.defaults.plugins.tooltip || {};
            Chart.defaults.plugins.tooltip.enabled = true;
            Chart.defaults.interaction = Chart.defaults.interaction || {};
            Chart.defaults.interaction.intersect = false;
            Chart.defaults.interaction.mode = 'nearest';
            Chart.defaults.events = ['mousemove','mouseout','click','touchstart','touchmove','touchend'];
            Chart.defaults.animation = false; // Disable global animations to prevent expansion effects
        }

        // Helper to guard tooltip callbacks from errors
        function safe(cb, fallback) {
            return function() {
                try { return cb.apply(this, arguments); }
                catch (err) { console.error('Tooltip callback error:', err); return fallback; }
            };
        }
        // Global chart registry
        const DASHBOARD_CHARTS = {};
        function registerChart(id, chart) { DASHBOARD_CHARTS[id] = chart; attachToolbar(id); }
        function attachToolbar(id){
            const holder = document.querySelector(`.chart-tools[data-chart="${id}"]`);
            if(!holder) return;
            holder.innerHTML = '';
            const btnPng = document.createElement('button');
            btnPng.type='button'; btnPng.title='Export PNG'; btnPng.innerHTML='ðŸ–¼ï¸';
            btnPng.addEventListener('click', ()=> exportChartPNG(id));
            const btnCopy = document.createElement('button');
            btnCopy.type='button'; btnCopy.title='Copy Image to Clipboard'; btnCopy.innerHTML='ðŸ“‹';
            btnCopy.addEventListener('click', ()=> copyChartToClipboard(id));
            holder.appendChild(btnPng); holder.appendChild(btnCopy);
        }
        function withForcedLightMode(cb){
            const wasDark = document.body.classList.contains('dark-mode');
            if(wasDark) document.body.classList.remove('dark-mode');
            try { cb(); } finally { if(wasDark) document.body.classList.add('dark-mode'); }
        }
        function exportChartPNG(id){
            const chart = DASHBOARD_CHARTS[id];
            if(!chart) return;
            withForcedLightMode(()=>{
                chart.update();
                const a = document.createElement('a');
                a.download = `${id}-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'_')}.png`;
                a.href = chart.toBase64Image('image/png',1);
                a.click();
            });
        }
        async function copyChartToClipboard(id){
            try {
                const chart = DASHBOARD_CHARTS[id];
                if(!chart) return;
                let dataUrl;
                withForcedLightMode(()=>{ chart.update(); dataUrl = chart.toBase64Image('image/png',1); });
                const res = await fetch(dataUrl);
                const blob = await res.blob();
                await navigator.clipboard.write([
                    new ClipboardItem({ [blob.type]: blob })
                ]);
                flashStatus(id, 'Copied');
            } catch(err){ console.error('Copy failed', err); flashStatus(id,'Copy failed'); }
        }
        function flashStatus(id, msg){
            const holder = document.querySelector(`.chart-tools[data-chart="${id}"]`);
            if(!holder) return;
            const span = document.createElement('span');
            span.style.fontSize = '.65rem'; span.style.marginLeft='4px'; span.style.opacity='0.85'; span.textContent=msg;
            holder.appendChild(span);
            setTimeout(()=> span.remove(), 1800);
        }
        // Dark mode toggle
        document.addEventListener('DOMContentLoaded', () => {
            const toggle = document.getElementById('darkModeToggle');
            if(toggle){
                toggle.addEventListener('click', () => {
                    const dark = document.body.classList.toggle('dark-mode');
                    toggle.setAttribute('aria-pressed', dark ? 'true' : 'false');
                    toggle.textContent = dark ? 'â˜€ï¸ Light' : 'ðŸŒ™ Dark';
                    // Refresh chart colors (basic adaptation by updating ticks & legend color)
                    Object.values(DASHBOARD_CHARTS).forEach(ch => {
                        if(!ch) return;
                        const color = dark ? '#e6e6e6' : '#212529';
                        if(ch.options.scales){
                            Object.values(ch.options.scales).forEach(scale => {
                                scale.ticks = scale.ticks || {}; scale.ticks.color = color;
                                scale.title = scale.title || {}; scale.title.color = color;
                                scale.grid = scale.grid || {}; scale.grid.color = dark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.08)';
                            });
                        }
                        if(ch.options.plugins && ch.options.plugins.legend){
                            ch.options.plugins.legend.labels = ch.options.plugins.legend.labels || {}; ch.options.plugins.legend.labels.color = color;
                        }
                        if(ch.options.plugins && ch.options.plugins.title){
                            ch.options.plugins.title.color = color;
                        }
                        ch.update('none');
                    });
                });
            }
        });
    </script>
    <style>
        body { background: #f8f9fa; }
        .dashboard-section { margin-bottom: 2rem; }
        /* Increased chart heights for better readability */
        .chart-container {
            height: 420px;
            position: relative;
            padding: .25rem .25rem .5rem;
        }
    .chart-container.heatmap-container { height: 620px; }
    .chart-container.small-chart { height: 360px; }
    .chart-container.tall-chart { height: 500px; }
    .chart-container.pie-chart { height: 440px; }
        .chart-container canvas { width:100% !important; height:100% !important; }
        @media (max-width: 992px) {
            .chart-container { height: 340px; }
            .chart-container.heatmap-container { height: 520px; }
            .chart-container.small-chart { height: 300px; }
            .chart-container.pie-chart { height: 360px; }
            .chart-container.tall-chart { height: 420px; }
        }
        canvas { 
            position: relative !important;
            z-index: 1 !important;
            pointer-events: auto; /* ensure hover/click are captured */
        }
        .kpi { font-size: 1.5rem; font-weight: bold; }
        .table-responsive { max-height: 400px; overflow-y: auto; }
        .border-left-warning { border-left: 4px solid #f39c12; }
        /* Professional theme accents */
        :root {
            --brand-primary: #0d6efd;
            --brand-accent: #6c5ce7;
            --brand-muted: #6c757d;
            --brand-bg-alt: #ffffff;
        }
        h3 { font-weight: 600; letter-spacing: .5px; }
        .section-heading-icon { font-size: 1.2rem; opacity: .7; margin-right: .35rem; }
        .meta-panel { background: var(--brand-bg-alt); border: 1px solid #e3e6ea; border-radius: .5rem; padding: 1rem 1.25rem; box-shadow: 0 1px 2px rgba(0,0,0,.05); }
        .meta-badge { display: inline-flex; flex-direction: column; padding: .5rem .75rem; background: #f1f3f5; border-radius: .5rem; min-width: 140px; margin: .25rem .5rem .25rem 0; }
        .meta-badge span.label { font-size: .7rem; text-transform: uppercase; letter-spacing: .05em; color: var(--brand-muted); }
        .meta-badge span.value { font-weight: 600; font-size: .95rem; }
        .kpi-cards .kpi-card { background: var(--brand-bg-alt); border: 1px solid #e3e6ea; border-radius: .65rem; padding: .9rem .95rem; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,.05); position: relative; }
        .kpi-cards .kpi-card .kpi-label { font-size: .7rem; text-transform: uppercase; color: var(--brand-muted); letter-spacing: .05em; margin-bottom: .25rem; font-weight: 600; }
        .kpi-cards .kpi-card .kpi-value { font-size: 1.35rem; font-weight: 700; color: #212529; }
        .kpi-cards .kpi-card .kpi-sub { font-size: .65rem; color: var(--brand-muted); }
        .chart-container canvas { outline: none; }
        footer.dashboard-footer { font-size: .7rem; color: var(--brand-muted); text-align: center; margin-top: 3rem; padding: 1rem 0 2rem; }
        .alert-info small, .alert-warning small { font-size: .7rem; }
    .chart-tools button { border: none; background: transparent; padding: 2px 6px; font-size: .8rem; cursor: pointer; color: var(--brand-muted); }
    .chart-tools button:hover { color: #000; }
    body.dark-mode { background:#121317; color:#e6e6e6; }
    body.dark-mode .meta-panel, body.dark-mode .kpi-cards .kpi-card, body.dark-mode .chart-container { background:#1e1f24; border-color:#2b2d33; }
    body.dark-mode .kpi-value { color:#fff; }
    body.dark-mode .meta-badge { background:#26272d; }
    body.dark-mode .alert-info { background:#243040; color:#d5e8ff; }
    body.dark-mode .alert-warning { background:#3a2f05; }
    body.dark-mode .badge.bg-primary { background:#0d6efd !important; }
    body.dark-mode .badge.bg-danger { background:#dc3545 !important; }
    body.dark-mode .table { color:#e6e6e6; }
    body.dark-mode .table-striped>tbody>tr:nth-of-type(odd)>* { --bs-table-accent-bg: rgba(255,255,255,0.03); }
    body.dark-mode .chart-tools button { color:#9aa0ac; }
    body.dark-mode .chart-tools button:hover { color:#fff; }
        
        /* Print styles for browser printing */
        @media print {
            body { background: white !important; font-size: 12px; }
            .dashboard-section { margin-bottom: 1.5rem; page-break-inside: avoid; }
            .chart-container { min-height: 280px; max-height: 320px; page-break-inside: avoid; }
            .table-responsive { max-height: none; overflow: visible; page-break-inside: avoid; }
            .kpi { font-size: 1.2rem; }
            h1 { font-size: 1.8rem; }
            h3 { font-size: 1.4rem; margin-bottom: 1rem; }
            .table { font-size: 11px; }
        }
    </style>
</head>
<body>
<div class="container py-4" id="dashboard">
    <div class="d-flex flex-wrap justify-content-between align-items-center mb-3">
        <h1 class="mb-0 text-center flex-grow-1">Work Item Analytics Dashboard</h1>
        <div class="ms-auto d-flex gap-2 mt-3 mt-md-0">
            <button id="darkModeToggle" class="btn btn-sm btn-outline-secondary" type="button" aria-pressed="false" aria-label="Toggle dark mode">ðŸŒ™ Dark</button>
        </div>
    </div>
    <div class="mb-3">
        <input type="file" id="csvFileInput" accept=".csv" class="form-control">
    </div>
    <div id="datasetMeta" class="meta-panel mb-3" aria-live="polite" aria-label="Dataset metadata summary" style="display:none;">
        <div class="d-flex flex-wrap" id="datasetMetaContent"></div>
    </div>
    <div id="kpiSection" class="dashboard-section row text-center"></div>
    
    <!-- Blocked Items Summary Section -->
    <div id="blockedSummarySection" class="dashboard-section" style="display: none;">
        <div class="alert alert-warning border-left-warning">
            <h4 class="alert-heading">ðŸš« Blocked Items Summary</h4>
            <div class="row" id="blockedSummaryContent">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>
    
    <div class="dashboard-section row">
    <div class="col-md-6 chart-container pie-chart">
            <div class="d-flex justify-content-between align-items-center mb-1 small fw-semibold"><span>PBIs Closed vs Open per Developer</span><div class="chart-tools" data-chart="ticketsPerPersonChart"></div></div>
            <canvas id="ticketsPerPersonChart"></canvas>
        </div>
    <div class="col-md-6 chart-container pie-chart">
            <div class="d-flex justify-content-between align-items-center mb-1 small fw-semibold"><span>Monthly PBIs Closed Trend</span><div class="chart-tools" data-chart="ticketsOverTimeChart"></div></div>
            <canvas id="ticketsOverTimeChart"></canvas>
        </div>
    </div>
    <div class="dashboard-section">
        <h3>Monthly Developer Performance Heatmap</h3>
        <div class="chart-container heatmap-container">
            <div class="d-flex justify-content-between align-items-center mb-1 small fw-semibold"><span>Monthly Developer Performance Heatmap</span><div class="chart-tools" data-chart="developerHeatmapChart"></div></div>
            <canvas id="developerHeatmapChart"></canvas>
        </div>
    </div>
    <div class="dashboard-section row">
    <div class="col-md-6 chart-container small-chart">
            <div class="d-flex justify-content-between align-items-center mb-1 small fw-semibold"><span>Current State Distribution</span><div class="chart-tools" data-chart="ticketStatePieChart"></div></div>
            <canvas id="ticketStatePieChart"></canvas>
        </div>
    <div class="col-md-6 chart-container small-chart">
            <div class="d-flex justify-content-between align-items-center mb-1 small fw-semibold"><span>Work Item Type Distribution</span><div class="chart-tools" data-chart="ticketTypePieChart"></div></div>
            <canvas id="ticketTypePieChart"></canvas>
        </div>
    </div>

    <div class="dashboard-section">
        <h3>PBI's by Blocked State</h3>
        <div class="alert alert-info mb-3">
            <strong>Note:</strong> Items with <code>DEBLOCKED = TRUE</code> are currently <strong>blocked</strong>. 
            Items with <code>DEBLOCKED = FALSE</code> are <strong>not blocked</strong>.<br>
            <strong>Important:</strong> Items with State = "Blocked" are excluded from analysis since we use the DEBLOCKED column for blocking representation.
            The table below shows blocking status based on the DEBLOCKED column only.
        </div>
        <div class="table-responsive">
            <table class="table table-striped" id="blockedStateTable">
                <thead><tr><th>Blocked Status</th><th>Count</th><th>Percentage</th><th>Avg Age (Blocked Items)</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <!-- Reordered Sections as requested -->
    <div class="dashboard-section">
        <h3>PBI Inflow vs Outflow Trends</h3>
    <div class="chart-container tall-chart">
            <div class="d-flex justify-content-between align-items-center mb-1 small fw-semibold"><span>PBI Inflow vs Outflow Trends</span><div class="chart-tools" data-chart="inflowOutflowChart"></div></div>
            <canvas id="inflowOutflowChart"></canvas>
        </div>
    </div>
    <div class="dashboard-section">
        <h3>Quarterly Closed PBI's & Average State Duration</h3>
    <div class="chart-container tall-chart">
            <div class="d-flex justify-content-between align-items-center mb-1 small fw-semibold"><span>Quarterly Closed & Avg State Duration</span><div class="chart-tools" data-chart="quarterlyClosedChart"></div></div>
            <canvas id="quarterlyClosedChart"></canvas>
        </div>
        <div class="alert alert-info mt-3">
            <strong>ðŸ“Š Blocked Duration Calculation:</strong> The red "Blocked" line shows the actual average number of days that PBI's were blocked (DEBLOCKED = TRUE) during their lifecycle. 
            This is calculated by counting all historical entries where DEBLOCKED = TRUE for each work item, providing real blocked time data rather than estimates.
        </div>
    </div>
    <div class="dashboard-section">
        <h3>Product Backlog Items - Aging Scatter Plot (State vs Age)</h3>
    <div class="chart-container tall-chart">
            <div class="d-flex justify-content-between align-items-center mb-1 small fw-semibold"><span>Aging Scatter Plot (State vs Age)</span><div class="chart-tools" data-chart="agingScatterChart"></div></div>
            <canvas id="agingScatterChart"></canvas>
        </div>
        <div class="row mt-3">
            <div class="col-md-12">
                <div class="alert alert-info">
                    <strong>Product Backlog Items Only:</strong> 
                    <span class="badge bg-danger me-2">Red = Blocked (DEBLOCKED = TRUE)</span>
                    <span class="badge bg-primary me-2">Blue = Regular Items (DEBLOCKED = FALSE)</span>
                    <br><small>Hover to see: Title, Current State, Total Age, Blocked Days, States Traversed & per-state age, Developer.</small>
                </div>
                <div id="healthIndicator" class="alert" style="border-left: 5px solid; margin-top: 10px;"></div>
            </div>
        </div>
    </div>
    <div class="dashboard-section">
        <h3>Features Created per Quarter</h3>
    <div class="chart-container small-chart">
            <div class="d-flex justify-content-between align-items-center mb-1 small fw-semibold"><span>Features Created per Quarter</span><div class="chart-tools" data-chart="featuresPerQuarterChart"></div></div>
            <canvas id="featuresPerQuarterChart"></canvas>
        </div>
        <div class="table-responsive mt-3">
            <table class="table table-striped" id="featuresTable">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Title</th>
                        <th>Created Date</th>
                        <th>State</th>
                        <th>Assigned To</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
</div>
<script>
function parseQuarter(dateStr) {
    if (!dateStr) return '';
    const cleanStr = String(dateStr).replace(/\"/g, '').trim();
    const [datePart] = cleanStr.split(' '); // Take only date part, ignore time
    if (!datePart || !datePart.includes('/')) return '';
    const parts = datePart.split('/');
    if (parts.length !== 3) return '';
    // CSV uses MM/DD/YYYY
    const [mm, dd, yyyy] = parts.map(p => p.trim());
    const m = parseInt(mm, 10);
    const y = parseInt(yyyy, 10);
    if (!m || !y) return '';
    const q = Math.floor((m - 1) / 3) + 1;
    return `Q${q} ${y}`;
}
function daysBetween(start, end) {
    if (!start || !end) {
        return null;
    }
    
    // Parse dates in MM/DD/YYYY format (consistent with temp2.csv)
    const parseDate = (dateStr) => {
        try {
            const cleanStr = String(dateStr).replace(/\"/g, '').trim();
            
            // Handle different date formats
            let datePart;
            if (cleanStr.includes(' ')) {
                [datePart] = cleanStr.split(' '); // Take only date part, ignore time
            } else {
                datePart = cleanStr;
            }
            
            // Use MM/DD/YYYY format (based on temp2.csv format)
            if (datePart.includes('/')) {
                const parts = datePart.split('/');
                if (parts.length === 3) {
                    const [month, day, year] = parts;
                    const parsedDate = new Date(year, month - 1, day);
                    return parsedDate;
                }
            }
            
            // Try other formats
            const fallbackDate = new Date(cleanStr);
            return fallbackDate;
        } catch (error) {
            console.error('Date parsing error:', error, 'Input:', dateStr);
            return null;
        }
    };
    
    const s = parseDate(start);
    const e = parseDate(end);
    
    if (!s || !e || isNaN(s) || isNaN(e)) {
        return null;
    }
    
    const diffTime = e - s;
    const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
    
    return diffDays;
}

// Calculate business days between two dates (excluding weekends)
function businessDaysBetween(startDate, endDate) {
    if (!startDate || !endDate) return null;
    
    const parseDate = (dateStr) => {
        try {
            const cleanStr = String(dateStr).replace(/\"/g, '').trim();
            let datePart;
            if (cleanStr.includes(' ')) {
                [datePart] = cleanStr.split(' ');
            } else {
                datePart = cleanStr;
            }
            
            if (datePart.includes('/')) {
                const parts = datePart.split('/');
                if (parts.length === 3) {
                    const [month, day, year] = parts;
                    return new Date(year, month - 1, day);
                }
            }
            return new Date(cleanStr);
        } catch (error) {
            console.error('Date parsing error in businessDaysBetween:', error);
            return null;
        }
    };
    
    const start = parseDate(startDate);
    const end = parseDate(endDate);
    
    if (!start || !end || isNaN(start) || isNaN(end)) return null;
    
    let businessDays = 0;
    const current = new Date(start);
    
    while (current <= end) {
        const dayOfWeek = current.getDay();
        // 0 = Sunday, 6 = Saturday
        if (dayOfWeek !== 0 && dayOfWeek !== 6) {
            businessDays++;
        }
        current.setDate(current.getDate() + 1);
    }
    
    return Math.max(0, businessDays - 1); // Subtract 1 to exclude the start date
}
function groupBy(arr, keyFn) {
    return arr.reduce((acc, item) => {
        const key = keyFn(item);
        acc[key] = acc[key] || [];
        acc[key].push(item);
        return acc;
    }, {});
}
function updateDashboard(data) {
    // Current date for comparison
    const todayRef = new Date();
    const todayStr = todayRef.toLocaleDateString('en-GB'); // DD/MM/YYYY format
    
    // Helper function to parse dates in MM/DD/YYYY format (based on temp2.csv format)
    function parseDate(dateStr) {
        if (!dateStr) return null;
        try {
            const cleanStr = String(dateStr).replace(/\"/g, '').trim();
            const [datePart] = cleanStr.split(' '); // Take only date part, ignore time
            
            if (datePart.includes('/')) {
                const parts = datePart.split('/');
                if (parts.length === 3) {
                    // Assume MM/DD/YYYY format based on temp2.csv
                    const [month, day, year] = parts;
                    const parsedDate = new Date(year, month - 1, day);
                    return parsedDate;
                }
            }
            
            // Fallback for other formats
            return new Date(cleanStr);
        } catch (error) {
            console.error('Date parsing error:', error, 'Input:', dateStr);
            return null;
        }
    }
    
    // Helper function to get closed date or use today's date
    function getClosedDate(row) {
        if (row['Closed Date']) {
            const closedDate = parseDate(row['Closed Date']);
            // If closed date is in the future, use today's date instead
            if (closedDate > todayRef) {
                return todayStr;
            }
            return row['Closed Date'];
        }
        return todayStr;
    }
    
    // Deduplicate data by Work Item ID and get the latest state for each work item
    const uniqueWorkItems = {};
    data.forEach(row => {
        const workItemId = row['Work Item Id'] || row['ID'];
        const stateChangeDate = parseDate(row['State Change Date'] || row['Created Date']);
        
        if (!uniqueWorkItems[workItemId] || 
            (stateChangeDate && parseDate(uniqueWorkItems[workItemId]['State Change Date'] || uniqueWorkItems[workItemId]['Created Date']) < stateChangeDate)) {
            uniqueWorkItems[workItemId] = row;
        }
    });
    
    // Convert back to array with unique work items
    const uniqueData = Object.values(uniqueWorkItems);
    // ================= Dataset Metadata Panel =================
    (function renderDatasetMeta(){
        const metaEl = document.getElementById('datasetMeta');
        if (!metaEl) return;
        const metaContent = document.getElementById('datasetMetaContent');
        const totalRows = data.length;
        const uniqueItems = uniqueData.length;
        const firstDate = data
            .map(r => parseDate(r['Created Date']))
            .filter(d => d && !isNaN(d))
            .sort((a,b)=>a-b)[0];
        const lastDate = data
            .map(r => parseDate(r['State Change Date'] || r['Closed Date'] || r['Changed Date'] || r['Created Date']))
            .filter(d => d && !isNaN(d))
            .sort((a,b)=>b-a)[0];
        const spanDays = (firstDate && lastDate) ? Math.max(1, Math.round((lastDate - firstDate)/(1000*60*60*24))) : 0;
        const people = new Set();
        uniqueData.forEach(r => { if (r['Assigned To']) people.add(r['Assigned To']); });
        const states = new Set(uniqueData.map(r => r['State']).filter(Boolean));
        const types = new Set(uniqueData.map(r => r['Work Item Type'] || r['Type']).filter(Boolean));
        const blockedCount = uniqueData.filter(r => (r['DEBLOCKED'] === 'TRUE' || r['DEBLOCKED'] === true || r['DEBLOCKED'] === 'True')).length;
        const blockedPct = uniqueItems ? ((blockedCount/uniqueItems)*100).toFixed(1) : '0.0';
        metaContent.innerHTML = `
            <div class="meta-badge" title="Total raw rows loaded from CSV"><span class="label">Raw Rows</span><span class="value">${totalRows}</span></div>
            <div class="meta-badge" title="Distinct work items after latest-state consolidation"><span class="label">Unique Items</span><span class="value">${uniqueItems}</span></div>
            <div class="meta-badge" title="Date span covered by dataset"><span class="label">Date Span</span><span class="value">${spanDays}d</span></div>
            <div class="meta-badge" title="First creation date detected"><span class="label">From</span><span class="value">${firstDate ? firstDate.toLocaleDateString() : 'â€”'}</span></div>
            <div class="meta-badge" title="Last activity / change date detected"><span class="label">To</span><span class="value">${lastDate ? lastDate.toLocaleDateString() : 'â€”'}</span></div>
            <div class="meta-badge" title="Distinct assignees (current state)"><span class="label">People</span><span class="value">${people.size}</span></div>
            <div class="meta-badge" title="Distinct states represented"><span class="label">States</span><span class="value">${states.size}</span></div>
            <div class="meta-badge" title="Distinct work item types"><span class="label">Types</span><span class="value">${types.size}</span></div>
            <div class="meta-badge" title="Items currently blocked (DEBLOCKED=TRUE)"><span class="label">Blocked</span><span class="value">${blockedCount} (${blockedPct}%)</span></div>
            <div class="meta-badge" title="Data refresh timestamp"><span class="label">Refreshed</span><span class="value">${new Date().toLocaleTimeString()}</span></div>
        `;
        metaEl.style.display = 'block';
    })();
    // ===========================================================
    // Restrict to Product Backlog Items for PBI-specific metrics and charts
    const pbisUnique = uniqueData.filter(row => (row['Work Item Type'] || '').toLowerCase() === 'product backlog item');
    
    console.log('Original data rows:', data.length);
    console.log('Unique work items after deduplication:', uniqueData.length);
    console.log('Sample unique item:', uniqueData[0]);
    console.log('Done PBI count:', pbisUnique.filter(row => row['State'] === 'Done').length);
    
    // Log first few done tickets for debugging
    const doneTickets = pbisUnique.filter(row => row['State'] === 'Done').slice(0, 3);
    console.log('Sample done tickets:', doneTickets.map(ticket => ({
        id: ticket['Work Item Id'],
        assignedTo: ticket['Assigned To'],
        startDate: ticket['Start Date'],
        closedDate: ticket['Closed Date'],
        stateChangeDate: ticket['State Change Date'],
        createdDate: ticket['Created Date']
    })));
    
    // Filter only Done tickets and apply proper closed date logic
    // Only PBIs are considered "tickets" for PBI-focused visuals
    const closedTickets = pbisUnique.filter(row => row['State'] === 'Done').map(row => {
        return { ...row, 'Closed Date': getClosedDate(row) };
    });
    
    // KPIs using unique work items
    const totalTickets = pbisUnique.length;
    const totalClosed = closedTickets.length;
    const people = [...new Set(pbisUnique.map(row => row['Assigned To']))].filter(Boolean);
    const avgClosedPerPerson = people.length > 0 ? (totalClosed / people.length).toFixed(2) : '0';
    
    // Debug calculations
    console.log('=== KPI CALCULATIONS DEBUG ===');
    console.log('Total unique work items:', totalTickets);
    console.log('Total closed PBIs:', totalClosed);
    console.log('Number of people:', people.length);
    console.log('People list:', people);
    console.log('Avg closed per person calculation:', totalClosed, '/', people.length, '=', avgClosedPerPerson);
    
    // Calculate open tickets and aging metrics early (exclude State = "Blocked" since we use DEBLOCKED column)
    const openUniqueTickets = pbisUnique.filter(row => {
        const state = row['State'] || '';
        return state !== 'Done' && state !== 'Removed' && state !== 'Closed' && state.toLowerCase() !== 'blocked';
    });
    
    // Calculate age for each open unique ticket
    const openUniqueTicketsWithAge = openUniqueTickets.map(row => {
        // Use Start Date if available, otherwise fall back to State Change Date, then Created Date
        let startDate = row['Start Date'] || row['State Change Date'] || row['Created Date'];
        
    const developmentStartDate = parseDate(startDate);
    const ageInDays = developmentStartDate ? Math.round((todayRef - developmentStartDate) / (1000 * 60 * 60 * 24)) : 0;
        return {
            ...row,
            ageInDays: Math.max(0, ageInDays), // Ensure non-negative age
            developmentStartDate: startDate
        };
    }).filter(ticket => ticket.ageInDays >= 0); // Only valid ages
    
    // Tickets closed per person
    const closedByPerson = {};
    closedTickets.forEach(row => {
        const person = row['Assigned To'];
        closedByPerson[person] = (closedByPerson[person] || 0) + 1;
    });
    // Tickets closed over time (monthly, quarterly, annual) - exclude future dates
    const closedByMonthRaw = closedTickets.map(row => {
        const closedDate = parseDate(row['Closed Date']);
        return {
            key: `${closedDate.getFullYear()}-${String(closedDate.getMonth()+1).padStart(2,'0')}`,
            date: closedDate
        };
    }).filter(item => item.date <= todayRef); // Only include dates up to today
    
    // Debug monthly calculations
    console.log('=== MONTHLY CALCULATIONS DEBUG ===');
    console.log('Closed tickets for monthly calc:', closedTickets.length);
    console.log('Sample closed tickets:', closedTickets.slice(0, 3).map(row => ({
        id: row['Work Item Id'],
        closedDate: row['Closed Date'],
        state: row['State']
    })));
    
    // Sort months chronologically
    const monthKeys = [...new Set(closedByMonthRaw.map(x => x.key))];
    monthKeys.sort((a, b) => {
        const [ay, am] = a.split('-').map(Number);
        const [by, bm] = b.split('-').map(Number);
        return ay === by ? am - bm : ay - by;
    });
    
    const closedByMonth = {};
    monthKeys.forEach(key => {
        closedByMonth[key] = closedTickets.filter(row => {
            const closedDate = parseDate(row['Closed Date']);
            return closedDate <= todayRef && `${closedDate.getFullYear()}-${String(closedDate.getMonth()+1).padStart(2,'0')}` === key;
        });
    });
    
    // Debug each month's count
    console.log('Monthly breakdown:');
    monthKeys.forEach(key => {
        console.log(`${key}: ${closedByMonth[key].length} PBI's`);
        if (closedByMonth[key].length > 0) {
            console.log('  Sample work items:', closedByMonth[key].slice(0, 3).map(row => row['Work Item Id']));
        }
    });
    
    const closedByQuarter = groupBy(closedTickets, row => parseQuarter(row['Closed Date']));
    const closedByYear = groupBy(closedTickets, row => {
        const closedDate = parseDate(row['Closed Date']);
        return closedDate.getFullYear();
    });
    // Ticket state pie using unique work items
    const stateCounts = {};
    uniqueData.forEach(row => {
        const state = row['State'] || 'Unknown';
        stateCounts[state] = (stateCounts[state] || 0) + 1;
    });
    // Ticket type pie using unique work items
    const typeCounts = {};
    uniqueData.forEach(row => {
        const type = row['Work Item Type'] || 'Unknown';
        typeCounts[type] = (typeCounts[type] || 0) + 1;
    });
    // Average time to close tickets by developer (from development start to Done state)
    console.log('=== STARTING AVERAGE TIME CALCULATION ===');
    const avgTimeStats = {};
    const doneTicketsForCalc = uniqueData.filter(row => row['State'] === 'Done');
    console.log('Done tickets for calculation:', doneTicketsForCalc.length);
    
    doneTicketsForCalc.forEach((row, index) => {
        const person = row['Assigned To'];
        const startDate = row['Start Date'] || row['State Change Date'] || row['Created Date'];
        const closedDate = row['Closed Date'] || row['State Change Date'];
        
        console.log(`\n--- Processing ticket ${index + 1} for ${person} ---`);
        console.log('Available date fields:', {
            'Start Date': row['Start Date'],
            'Closed Date': row['Closed Date'],
            'State Change Date': row['State Change Date'],
            'Created Date': row['Created Date']
        });
        console.log('Using dates:', { startDate, closedDate });
        
        if (startDate && closedDate) {
            const days = daysBetween(startDate, closedDate);
            console.log(`Days result for ${person}:`, days);
            
            if (days !== null && days >= 0) {
                if (!avgTimeStats[person]) avgTimeStats[person] = { totalDays: 0, count: 0 };
                avgTimeStats[person].totalDays += days;
                avgTimeStats[person].count += 1;
                console.log(`Updated stats for ${person}:`, avgTimeStats[person]);
            } else {
                console.log(`Invalid days result for ${person}:`, days);
            }
        } else {
            console.log(`Missing dates for ${person}`);
        }
    });
    
    console.log('Final avgTimeStats:', avgTimeStats);
    const avgTimeRows = Object.entries(avgTimeStats).map(([person, stats]) => ({
        developer: person,
        avgDays: stats.count ? (stats.totalDays / stats.count).toFixed(2) : 'N/A',
        count: stats.count
    })).sort((a, b) => {
        // Sort by average days (ascending), treating 'N/A' as infinity
        const aAvg = a.avgDays === 'N/A' ? Infinity : parseFloat(a.avgDays);
        const bAvg = b.avgDays === 'N/A' ? Infinity : parseFloat(b.avgDays);
        return aAvg - bAvg;
    });
    
    // Median time to close tickets by developer (development cycle time)
    function median(arr) {
        arr = arr.filter(x => typeof x === 'number' && !isNaN(x) && x >= 0);
        if (arr.length === 0) return 'N/A';
        arr.sort((a,b) => a-b);
        const mid = Math.floor(arr.length/2);
        return arr.length % 2 ? arr[mid] : ((arr[mid-1]+arr[mid])/2).toFixed(2);
    }
    console.log('=== STARTING MEDIAN TIME CALCULATION ===');
    const medianTimeStats = {};
    doneTicketsForCalc.forEach((row, index) => {
        const person = row['Assigned To'];
        const startDate = row['Start Date'] || row['State Change Date'] || row['Created Date'];
        const closedDate = row['Closed Date'] || row['State Change Date'];
        
        if (startDate && closedDate) {
            const days = daysBetween(startDate, closedDate);
            
            if (days !== null && days >= 0) {
                if (!medianTimeStats[person]) medianTimeStats[person] = [];
                medianTimeStats[person].push(days);
                console.log(`Added ${days} days for ${person}. Array now:`, medianTimeStats[person]);
            }
        }
    });
    
    console.log('Final medianTimeStats:', medianTimeStats);
    const medianTimeRows = Object.entries(medianTimeStats).map(([person, arr]) => ({
        developer: person,
        medianDays: arr.length ? median(arr) : 'N/A',
        count: arr.length
    })).sort((a, b) => {
        // Sort by median days (ascending), treating 'N/A' as infinity
        const aMedian = a.medianDays === 'N/A' ? Infinity : parseFloat(a.medianDays);
        const bMedian = b.medianDays === 'N/A' ? Infinity : parseFloat(b.medianDays);
        return aMedian - bMedian;
    });
    
    // ===== TICKET AGING ANALYSIS =====
    
    // Filter open tickets (not Done/Closed)
    const openTickets = data.filter(row => {
        const state = row['State'] || '';
        return state !== 'Done' && state !== 'Closed' && state !== 'Resolved' && state !== '';
    });
    
    // Calculate age for open tickets based on development start date
    const openTicketsWithAge = openTickets.map(row => {
        // Use Start Date if available, otherwise fall back to State Change Date, then Created Date
        let startDate = row['Start Date'] || row['State Change Date'] || row['Created Date'];
        
        const developmentStartDate = parseDate(startDate);
    const ageInDays = developmentStartDate ? Math.round((todayRef - developmentStartDate) / (1000 * 60 * 60 * 24)) : 0;
        return {
            ...row,
            ageInDays: Math.max(0, ageInDays), // Ensure non-negative age
            developmentStartDate: startDate
        };
    }).filter(ticket => ticket.ageInDays >= 0); // Only valid ages
    
    // Update KPIs with aging metrics using unique work items
    const openTicketsCount = openUniqueTickets.length;
    // Removed Avg Age (Open) KPI per request
    
    document.getElementById('kpiSection').innerHTML = `
        <div class="kpi-cards d-flex flex-wrap gap-3" role="list" aria-label="Key performance indicators">
            <div class="kpi-card flex-grow-1" role="listitem" tabindex="0" aria-label="Total PBIs ${totalTickets}">
                <div class="kpi-label">Total PBIs</div>
                <div class="kpi-value">${totalTickets}</div>
                <div class="kpi-sub">All unique work items</div>
            </div>
            <div class="kpi-card flex-grow-1" role="listitem" tabindex="0" aria-label="Closed PBIs ${totalClosed}">
                <div class="kpi-label">Closed PBIs</div>
                <div class="kpi-value">${totalClosed}</div>
                <div class="kpi-sub">Lifecycle completed</div>
            </div>
            <div class="kpi-card flex-grow-1" role="listitem" tabindex="0" aria-label="Open PBIs ${openTicketsCount}">
                <div class="kpi-label">Open PBIs</div>
                <div class="kpi-value">${openTicketsCount}</div>
                <div class="kpi-sub">Currently active</div>
            </div>
            <div class="kpi-card flex-grow-1" role="listitem" tabindex="0" aria-label="Average closed per person ${avgClosedPerPerson}">
                <div class="kpi-label">Avg Closed / Person</div>
                <div class="kpi-value">${avgClosedPerPerson}</div>
                <div class="kpi-sub">Throughput efficiency</div>
            </div>
        </div>`;
    
    // Calculate and display blocked items summary (exclude State = "Blocked" since we use DEBLOCKED column)
    const filteredDataForSummary = uniqueData.filter(row => {
        const state = row['State'] || '';
        return state.toLowerCase() !== 'blocked'; // Exclude items with State = "Blocked"
    });
    
    const totalBlockedItems = filteredDataForSummary.filter(row => {
        const deblocked = row['DEBLOCKED'];
        return (deblocked === 'TRUE' || deblocked === true || deblocked === 'True');
    });
    
    if (totalBlockedItems.length > 0) {
        const blockedPercentage = ((totalBlockedItems.length / filteredDataForSummary.length) * 100).toFixed(1);
        
        // Calculate average age of blocked items
        let totalBlockedAge = 0;
        let blockedItemsWithAge = 0;
        
        totalBlockedItems.forEach(item => {
            const createdDate = parseDate(item['Created Date']);
            if (createdDate) {
                const ageInDays = Math.floor((todayRef - createdDate) / (1000 * 60 * 60 * 24));
                totalBlockedAge += ageInDays;
                blockedItemsWithAge++;
            }
        });
        
        const avgBlockedAge = blockedItemsWithAge > 0 ? (totalBlockedAge / blockedItemsWithAge).toFixed(1) : 0;
        
        // Group blocked items by state
        const blockedByStateForSummary = {};
        totalBlockedItems.forEach(item => {
            const state = item['State'] || 'Unknown';
            if (!blockedByStateForSummary[state]) {
                blockedByStateForSummary[state] = 0;
            }
            blockedByStateForSummary[state]++;
        });
        
        // Show the blocked summary section
        document.getElementById('blockedSummarySection').style.display = 'block';
        document.getElementById('blockedSummaryContent').innerHTML = `
            <div class="col-md-3">
                <strong>Total Blocked:</strong><br>
                <span class="text-danger" style="font-size: 1.5rem;">${totalBlockedItems.length}</span>
                <small class="d-block text-muted">(${blockedPercentage}% of all PBI's)</small>
            </div>
            <div class="col-md-3">
                <strong>Avg Blocked Age:</strong><br>
                <span class="text-warning" style="font-size: 1.5rem;">${avgBlockedAge}</span>
                <small class="d-block text-muted">days</small>
            </div>
            <div class="col-md-6">
                <strong>Blocked by State:</strong><br>
                ${Object.entries(blockedByStateForSummary)
                    .sort((a, b) => b[1] - a[1])
                    .map(([state, count]) => `<span class="badge bg-warning text-dark me-1">${state}: ${count}</span>`)
                    .join(' ')}
            </div>
        `;
    } else {
        // Hide the blocked summary section if no blocked items
        document.getElementById('blockedSummarySection').style.display = 'none';
    }
    // Stacked bar: PBIs Closed vs Open per developer
    const tppCtx = document.getElementById('ticketsPerPersonChart').getContext('2d');
    // Derive open PBIs per person from openUniqueTickets (current open unique PBIs)
    const openByPerson = {};
    openUniqueTickets.forEach(row => {
        const assignee = (row['Assigned To'] || 'Unassigned').trim();
        openByPerson[assignee] = (openByPerson[assignee] || 0) + 1;
    });
    // Closed already in closedByPerson
    const allPeople = Array.from(new Set([...Object.keys(closedByPerson), ...Object.keys(openByPerson)])).sort();
    const closedData = allPeople.map(p => closedByPerson[p] || 0);
    const openData = allPeople.map(p => openByPerson[p] || 0);
    registerChart('ticketsPerPersonChart', new Chart(tppCtx, {
        type: 'bar',
        data: {
            labels: allPeople,
            datasets: [
                {
                    label: "Closed",
                    data: closedData,
                    backgroundColor: 'rgba(54, 162, 235, 0.7)',
                    stack: 'pbis'
                },
                {
                    label: "Open",
                    data: openData,
                    backgroundColor: 'rgba(255, 159, 64, 0.8)',
                    stack: 'pbis'
                }
            ]
        },
        options: {
            animation: false,
            responsive: true,
            maintainAspectRatio: false,
            events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
            interaction: { intersect: false, mode: 'index' },
            plugins: {
                legend: { display: true, position: 'top' },
                tooltip: {
                    enabled: true,
                    mode: 'index',
                    callbacks: {
                        title: safe(function(ctx){ return ctx[0].label; }, ''),
                        label: safe(function(context){
                            if (context.dataset.label === 'Closed') {
                                return `Closed PBIs: ${context.parsed.y}`;
                            } else if (context.dataset.label === 'Open') {
                                return `Open PBIs: ${context.parsed.y}`;
                            }
                            return `${context.dataset.label}: ${context.parsed.y}`;
                        }, ''),
                        afterBody: safe(function(context){
                            // Provide totals line
                            const idx = context[0].dataIndex;
                            const closedVal = closedData[idx];
                            const openVal = openData[idx];
                            const total = closedVal + openVal;
                            return [`Total PBIs: ${total}`];
                        }, [])
                    }
                }
            },
            scales: {
                x: { stacked: true, ticks: { autoSkip: true, maxRotation: 30 } },
                y: { stacked: true, beginAtZero: true }
            }
        }
    }));
    // Tickets over time chart (monthly, ordered)
    const totCtx = document.getElementById('ticketsOverTimeChart').getContext('2d');
    registerChart('ticketsOverTimeChart', new Chart(totCtx, {
        type: 'line',
        data: {
            labels: monthKeys,
            datasets: [{
                label: 'PBI\'s Closed (Monthly)',
                data: monthKeys.map(key => closedByMonth[key].length),
                borderColor: 'rgba(255,99,132,1)',
                backgroundColor: 'rgba(255,99,132,0.2)',
                fill: true
            }]
        },
        options: {
            animation: false,
            responsive: true,
            maintainAspectRatio: false,
            events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
            interaction: { intersect: false, mode: 'nearest' },
            plugins: {
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: safe(function(context) { return context[0].label; }, ''),
                        label: safe(function(context) { return `PBI's Closed: ${context.parsed.y}`; }, '')
                    }
                }
            }
        }
    }));
    
    // Inflow vs Outflow Chart - Calculate opened and closed tickets per month
    const inflowData = {}; // Tickets opened per month
    const outflowData = {}; // Tickets closed per month
    
    // Calculate inflow (tickets created/opened per month)
    pbisUnique.forEach(row => {
        const createdDate = parseDate(row['Created Date']);
        if (createdDate && createdDate <= new Date()) {
            const monthKey = `${createdDate.getFullYear()}-${String(createdDate.getMonth() + 1).padStart(2, '0')}`;
            inflowData[monthKey] = (inflowData[monthKey] || 0) + 1;
        }
    });
    
    // Calculate outflow (tickets closed per month) 
    closedTickets.forEach(row => {
        const closedDate = parseDate(row['Closed Date']);
        if (closedDate && closedDate <= new Date()) {
            const monthKey = `${closedDate.getFullYear()}-${String(closedDate.getMonth() + 1).padStart(2, '0')}`;
            outflowData[monthKey] = (outflowData[monthKey] || 0) + 1;
        }
    });
    
    // Create combined month keys for both inflow and outflow
    const allMonthKeys = [...new Set([...Object.keys(inflowData), ...Object.keys(outflowData)])].sort();
    
    const inflowOutflowCtx = document.getElementById('inflowOutflowChart').getContext('2d');
    registerChart('inflowOutflowChart', new Chart(inflowOutflowCtx, {
        type: 'line',
        data: {
            labels: allMonthKeys,
            datasets: [
                {
                    label: 'Inflow (PBI\'s Opened)',
                    data: allMonthKeys.map(key => inflowData[key] || 0),
                    borderColor: '#3498DB',
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 5,
                    pointHoverRadius: 8,
                    pointBackgroundColor: '#3498DB',
                    pointBorderColor: '#FFFFFF',
                    pointBorderWidth: 2
                },
                {
                    label: 'Outflow (PBI\'s Closed)',
                    data: allMonthKeys.map(key => outflowData[key] || 0),
                    borderColor: '#27AE60',
                    backgroundColor: 'rgba(39, 174, 96, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 5,
                    pointHoverRadius: 8,
                    pointBackgroundColor: '#27AE60',
                    pointBorderColor: '#FFFFFF',
                    pointBorderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Monthly Ticket Flow Trends',
                    font: { size: 16, weight: 'bold' },
                    color: '#2C3E50'
                },
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        font: { size: 12 },
                        color: '#2C3E50'
                    }
                },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: safe(function(context) {
                            return `Month: ${context[0].label}`;
                        }, ''),
                        label: safe(function(context) {
                            const datasetLabel = context.dataset.label;
                            const value = context.parsed.y;
                            return `${datasetLabel}: ${value} tickets`;
                        }, ''),
                        afterBody: safe(function(context) {
                            const monthKey = context[0].label;
                            const inflow = inflowData[monthKey] || 0;
                            const outflow = outflowData[monthKey] || 0;
                            const netFlow = inflow - outflow;
                            const netLabel = netFlow > 0 ? 'Net Increase' : netFlow < 0 ? 'Net Decrease' : 'Net Neutral';
                            return [`Net Flow: ${netFlow} tickets (${netLabel})`];
                        }, [])
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Month',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    grid: {
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Number of Tickets',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                }
            }
        }
    }));
    
    // Monthly Developer Performance Heatmap
    const monthlyDeveloperData = {};
    const developerSet = new Set();
    const monthSet = new Set();
    
    // Process closed tickets to create monthly developer matrix
    closedTickets.forEach(row => {
        const closedDate = parseDate(row['Closed Date']);
        const developer = row['Assigned To'] || 'Unassigned';
        
        if (closedDate && developer) {
            const monthKey = `${closedDate.toLocaleString('default', { month: 'long' })} ${closedDate.getFullYear()}`;
            
            // Initialize data structure
            if (!monthlyDeveloperData[monthKey]) {
                monthlyDeveloperData[monthKey] = {};
            }
            if (!monthlyDeveloperData[monthKey][developer]) {
                monthlyDeveloperData[monthKey][developer] = 0;
            }
            
            monthlyDeveloperData[monthKey][developer] += 1;
            developerSet.add(developer);
            monthSet.add(monthKey);
        }
    });
    
    // Sort months chronologically
    const sortedMonths = Array.from(monthSet).sort((a, b) => {
        const dateA = new Date(a);
        const dateB = new Date(b);
        return dateA - dateB;
    });
    
    const sortedDevelopers = Array.from(developerSet).sort();
    
    console.log('Debug Heatmap Data:');
    console.log('Sorted Months:', sortedMonths);
    console.log('Sorted Developers:', sortedDevelopers);
    console.log('Monthly Developer Data:', monthlyDeveloperData);
    
    // Create heatmap data structure for Chart.js
    const heatmapData = [];
    
    // Calculate min and max values for dynamic color scaling
    const allValues = Object.values(monthlyDeveloperData).flatMap(month => 
        Object.values(month)
    ).filter(val => val > 0); // Exclude zeros from min/max calculation
    
    const maxValue = allValues.length > 0 ? Math.max(...allValues) : 0;
    const minValue = allValues.length > 0 ? Math.min(...allValues) : 0;
    
    console.log(`Heatmap value range: min=${minValue}, max=${maxValue}`);
    console.log('Sample values for color scaling:', allValues.slice(0, 10));
    
    sortedMonths.forEach((month, monthIndex) => {
        sortedDevelopers.forEach((developer, devIndex) => {
            const value = monthlyDeveloperData[month] && monthlyDeveloperData[month][developer] ? 
                monthlyDeveloperData[month][developer] : 0;
            
            heatmapData.push({
                x: devIndex,   // Developer index on X-axis
                y: monthIndex, // Month index on Y-axis
                v: value
            });
        });
    });
    
    console.log('Heatmap Data Points:', heatmapData);
    console.log('Max Value:', maxValue);
    
    // Create custom heatmap using scatter plot with sized points
    const developerHeatmapCtx = document.getElementById('developerHeatmapChart').getContext('2d');

    // Measure longest month label to compute dynamic right padding and avoid crossing with axis title
    developerHeatmapCtx.save();
    developerHeatmapCtx.font = 'bold 13px Arial';
    const maxMonthLabelWidth = sortedMonths.length
        ? Math.max(...sortedMonths.map(m => developerHeatmapCtx.measureText(String(m)).width))
        : 0;
    developerHeatmapCtx.restore();
    const rightLabelOffset = 12; // space from chart area to month labels
    const titleGap = 24;         // gap between month labels and rotated axis title
    const monthsTitleOffset = rightLabelOffset + maxMonthLabelWidth + titleGap; // used by plugin
    const dynamicRightPadding = Math.ceil(monthsTitleOffset + 40); // ensure title has breathing room

    // Function to get color based on value using dynamic heat mapping
    function getHeatmapColor(value, maxValue, minValue) {
        if (value === 0) return 'rgba(255, 152, 0, 0.8)'; // Orange for zero (no white)
        
        // Calculate the range and position within that range
        const range = maxValue - minValue;
        if (range === 0) {
            // All values are the same, use medium green
            return 'rgba(76, 175, 80, 0.8)';
        }
        
        // For value = 1, always use yellow
        if (value === 1) {
            return 'rgba(255, 235, 59, 0.9)'; // Yellow for 1
        }
        
        // For value = 2, always use light green
        if (value === 2) {
            return 'rgba(139, 195, 74, 0.8)'; // Light green for 2
        }
        
        // For values > 2, use dynamic scaling
        if (value > 2) {
            // Normalize value to 0-1 scale within the range above 2
            const adjustedMin = Math.max(3, minValue);
            const adjustedRange = maxValue - adjustedMin;
            
            if (adjustedRange <= 0) {
                return 'rgba(76, 175, 80, 0.9)'; // Medium green if all values are 2 or below
            }
            
            const normalizedValue = (value - adjustedMin) / adjustedRange;
            
            // Create heat map colors from medium to dark green for values > 2
            if (normalizedValue >= 0.7) {
                // Top 30% - Dark green
                return 'rgba(27, 94, 32, 1.0)';
            } else if (normalizedValue >= 0.4) {
                // 40-70% - Medium-dark green
                return 'rgba(46, 125, 50, 0.9)';
            } else {
                // Bottom 40% of values > 2 - Medium green
                return 'rgba(76, 175, 80, 0.8)';
            }
        }
        
        // Fallback (shouldn't reach here)
        return 'rgba(76, 175, 80, 0.8)';
    }
    
    registerChart('developerHeatmapChart', new Chart(developerHeatmapCtx, {
        type: 'scatter',
        data: {
            datasets: [{
                label: 'PBI\'s Closed',
                data: heatmapData.map(point => ({
                    x: point.x,
                    y: point.y,
                    value: point.v
                })),
                backgroundColor: heatmapData.map(point => getHeatmapColor(point.v, maxValue, minValue)),
                borderColor: '#FFFFFF',
                borderWidth: 1,
                pointStyle: 'rect',
                // Keep a tiny point for tooltip anchoring; plugin draws the full cell
                pointRadius: 2,
                pointHoverRadius: 2,
                pointHitRadius: 28
            }]
        },
        options: {
            animation: false,
            responsive: true,
            maintainAspectRatio: false,
            events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
            interaction: { intersect: false, mode: 'nearest' },
            hover: { mode: 'nearest', intersect: false, animationDuration: 0 },
            layout: {
                // Right padding is dynamic to prevent the rotated 'Months' title from overlapping month labels
                padding: { left: 80, right: dynamicRightPadding, top: 60, bottom: 160 }
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Monthly PBI Closure Heatmap by Developer',
                    font: { size: 16, weight: 'bold' },
                    color: '#2C3E50',
                    padding: { top: 8, bottom: 12 }
                },
                legend: { display: false },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: function(context) {
                            const point = context[0];
                            const devIndex = Math.round(point.parsed.x);
                            const monthIndex = Math.round(point.parsed.y);
                            const month = sortedMonths[monthIndex] || 'Unknown';
                            const developer = sortedDevelopers[devIndex] || 'Unknown';
                            return `${developer} - ${month}`;
                        },
                        label: function(context) {
                            return `PBI's Closed: ${context.raw.value}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'linear',
                    position: 'top',
                    min: -0.5,
                    max: sortedDevelopers.length - 0.5,
                    title: {
                        display: false,
                        text: 'Developers',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    ticks: {
                        display: false,
                        stepSize: 1,
                        align: 'center',
                        crossAlign: 'center',
                        callback: function(value) {
                            const devIndex = Math.round(value);
                            const fullName = sortedDevelopers[devIndex];
                            return fullName ? fullName.split(' ')[0] : '';
                        },
                        maxRotation: 0,
                        font: { size: 14, weight: 'bold' },
                        padding: 16
                    },
                    grid: { display: false }
                },
                y: {
                    type: 'linear',
                    min: -0.5,
                    max: sortedMonths.length - 0.5,
                    title: {
                        display: false,
                        text: 'Months',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    ticks: {
                        display: false,
                        stepSize: 1,
                        align: 'center',
                        crossAlign: 'center',
                        callback: function(value) {
                            const monthIndex = Math.round(value);
                            const label = sortedMonths[monthIndex];
                            // Show short month and year
                            return label ? label : '';
                        },
                        font: { size: 13, weight: 'bold' },
                        padding: 12
                    },
                    grid: { display: false }
                }
            }
        },
        plugins: [
            // Draw full cell rectangles behind points to fill gaps
            {
                id: 'heatmapCells',
                beforeDatasetsDraw(chart) {
                    const { ctx, scales, chartArea } = chart;
                    const xScale = scales.x;
                    const yScale = scales.y;
                    const meta = chart.getDatasetMeta(0);
                    ctx.save();
                    // Clip to chart area to avoid drawing outside axes
                    ctx.beginPath();
                    ctx.rect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                    ctx.clip();
                    heatmapData.forEach((point, index) => {
                        const element = meta.data[index];
                        if (!element) return;
                        // Compute pixel bounds for the cell (x=developer index, y=month index)
                        const xPix1 = xScale.getPixelForValue(point.x - 0.5);
                        const xPix2 = xScale.getPixelForValue(point.x + 0.5);
                        const yPix1 = yScale.getPixelForValue(point.y - 0.5);
                        const yPix2 = yScale.getPixelForValue(point.y + 0.5);
                        const left = Math.min(xPix1, xPix2);
                        const right = Math.max(xPix1, xPix2);
                        const top = Math.min(yPix1, yPix2);
                        const bottom = Math.max(yPix1, yPix2);
                        const width = right - left;
                        const height = bottom - top;
                        if (width <= 0 || height <= 0) return;
                        // Fill the entire cell (touching edges) for a fully colored heatmap
                        ctx.fillStyle = getHeatmapColor(point.v, maxValue, minValue);
                        ctx.fillRect(left, top, width, height);
                    });
                    ctx.restore();
                }
            },
            // Draw centered developer labels (bottom) and month labels (right)
            {
                id: 'heatmapAxisLabels',
                afterDatasetsDraw(chart) {
                    const { ctx, chartArea, scales } = chart;
                    const xScale = scales.x;
                    const yScale = scales.y;
                    ctx.save();
                    // Developers on bottom, centered per column
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#2C3E50';
                    for (let i = 0; i < sortedDevelopers.length; i++) {
                        const x = xScale.getPixelForValue(i);
                        const name = (sortedDevelopers[i] || '').split(' ')[0] || '';
                        ctx.fillText(name, x, chartArea.bottom + 8);
                    }
                    // Months on right, centered per row
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.font = 'bold 13px Arial';
                    for (let j = 0; j < sortedMonths.length; j++) {
                        const y = yScale.getPixelForValue(j);
                        const label = sortedMonths[j] || '';
                        // Draw month labels with a fixed offset from the chart area
                        ctx.fillText(label, chartArea.right + rightLabelOffset, y);
                    }
                    // Custom axis titles
                    // Bottom title (Developers)
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('Developers', chartArea.left + chartArea.width / 2, chartArea.bottom + 40);
                    // Right title (Months)
                    ctx.save();
                    // Place rotated title to the right of the longest month label to avoid crossing
                    ctx.translate(chartArea.right + monthsTitleOffset, chartArea.top + chartArea.height / 2);
                    ctx.rotate(Math.PI / 2);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Months', 0, 0);
                    ctx.restore();
                    ctx.restore();
                }
            },
            // Draw count labels on top of the cell color
            {
                id: 'heatmapPointLabels',
                afterDatasetsDraw(chart) {
                    const { ctx } = chart;
                    const meta = chart.getDatasetMeta(0);
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = 'bold 15px Arial';
                    heatmapData.forEach((point, index) => {
                        const element = meta.data[index];
                        if (!element) return;
                        const { x, y } = element;
                        const value = point.v;
                        let color = '#000';
                        if (value === 0) color = '#000';
                        else if (value >= 7) color = '#fff';
                        ctx.fillStyle = color;
                        ctx.fillText(String(value), x, y);
                    });
                    ctx.restore();
                }
            }
        ]
    }));
    
    // Add a dynamic legend/scale for the heatmap
    const heatmapLegendHtml = `
        <div style="margin-top: 10px; text-align: center;">
            <strong>Heat Map Scale (PBI Count):</strong>
            <span style="display: inline-block; margin: 0 10px;">
                <span style="background: rgba(255, 152, 0, 0.8); padding: 8px 12px; margin: 2px; border: 1px solid #cc8400; color: #000; font-weight: bold;">0</span>
                <span style="background: rgba(255, 235, 59, 0.9); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #000; font-weight: bold;">1</span>
                <span style="background: rgba(139, 195, 74, 0.8); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #000; font-weight: bold;">2</span>
                <span style="background: rgba(76, 175, 80, 0.8); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #000; font-weight: bold;">3-${Math.round(maxValue * 0.7)}</span>
                <span style="background: rgba(46, 125, 50, 0.9); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #fff; font-weight: bold;">${Math.round(maxValue * 0.7) + 1}-${Math.round(maxValue * 0.9)}</span>
                <span style="background: rgba(27, 94, 32, 1.0); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #fff; font-weight: bold;">${Math.round(maxValue * 0.9) + 1}+</span>
            </span>
        </div>
    `;
    
    // Insert legend after the chart
    document.getElementById('developerHeatmapChart').parentNode.insertAdjacentHTML('afterend', heatmapLegendHtml);
    
    // Quarterly Closed PBI's & Average State Duration Analysis
    const quarterlyClosedData = {};
    
    // First, let's group data by Work Item Id to calculate actual blocked days
    const workItemHistory = {};
    data.forEach(row => {
        const workItemId = row['Work Item Id'];
        if (!workItemHistory[workItemId]) {
            workItemHistory[workItemId] = [];
        }
        workItemHistory[workItemId].push(row);
    });
    
    // Process closed tickets to calculate quarterly data with actual blocked time
    closedTickets.forEach(row => {
        const closedDate = parseDate(row['Closed Date']);
        const createdDate = parseDate(row['Created Date']);
        const workItemId = row['Work Item Id'];
        
        if (closedDate && createdDate && workItemHistory[workItemId]) {
            // Calculate quarter key
            const year = closedDate.getFullYear();
            const quarter = Math.ceil((closedDate.getMonth() + 1) / 3);
            const quarterKey = `${year}-Q${quarter}`;
            
            // Initialize quarter data if not exists
            if (!quarterlyClosedData[quarterKey]) {
                quarterlyClosedData[quarterKey] = {
                    totalClosed: 0,
                    statesDuration: {},
                    totalDurationAcrossStates: 0,
                    pbiCount: 0,
                    blockedInfo: { totalBlockedDays: 0, blockedCount: 0 }
                };
            }
            
            // Calculate total time from creation to closure
            const totalDays = Math.max(0, Math.floor((closedDate - createdDate) / (1000 * 60 * 60 * 24)));
            
            // Calculate ACTUAL blocked days from the history
            const workItemHistoryData = workItemHistory[workItemId];
            let actualBlockedDays = 0;
            let wasEverBlocked = false;
            
            // Count consecutive days where DEBLOCKED = TRUE
            const sortedHistory = workItemHistoryData.sort((a, b) => {
                const dateA = parseDate(a['Date']);
                const dateB = parseDate(b['Date']);
                return dateA - dateB;
            });
            
            sortedHistory.forEach(historyRow => {
                const isBlocked = historyRow['DEBLOCKED'] && 
                                 historyRow['DEBLOCKED'].toString().toUpperCase() === 'TRUE';
                if (isBlocked) {
                    actualBlockedDays++;
                    wasEverBlocked = true;
                }
            });
            
            // Get current state for estimation purposes
            const currentState = row['State'] || 'Unknown';
            
            // Calculate estimated state durations using actual blocked time
            const estimatedStateDurations = calculateEstimatedStateDurationsWithActualBlocking(
                totalDays, currentState, actualBlockedDays, wasEverBlocked
            );
            
            // Add to quarterly data
            quarterlyClosedData[quarterKey].totalClosed += 1;
            quarterlyClosedData[quarterKey].totalDurationAcrossStates += totalDays;
            quarterlyClosedData[quarterKey].pbiCount += 1;
            
            // Track actual blocked information
            if (wasEverBlocked && actualBlockedDays > 0) {
                quarterlyClosedData[quarterKey].blockedInfo.totalBlockedDays += actualBlockedDays;
                quarterlyClosedData[quarterKey].blockedInfo.blockedCount += 1;
                
                // Add actual blocked state to estimations
                estimatedStateDurations['Blocked'] = actualBlockedDays;
            }
            
            // Aggregate state durations
            Object.entries(estimatedStateDurations).forEach(([state, duration]) => {
                if (!quarterlyClosedData[quarterKey].statesDuration[state]) {
                    quarterlyClosedData[quarterKey].statesDuration[state] = { totalDays: 0, count: 0 };
                }
                quarterlyClosedData[quarterKey].statesDuration[state].totalDays += duration;
                quarterlyClosedData[quarterKey].statesDuration[state].count += 1;
            });
        }
    });
    
    // Helper function to estimate state durations using actual blocked time from DEBLOCKED column
    function calculateEstimatedStateDurationsWithActualBlocking(totalDays, finalState, actualBlockedDays, wasEverBlocked = false) {
        const durations = {};
        
        if (totalDays <= 0) return durations;
        
        // Use actual blocked days from the data
        let availableDays = totalDays;
        if (wasEverBlocked && actualBlockedDays > 0) {
            // Ensure blocked days don't exceed total days
            const blockedDays = Math.min(actualBlockedDays, totalDays);
            availableDays = totalDays - blockedDays;
            durations['Blocked'] = blockedDays;
        }
        
        // Apply pattern based on final state for remaining time
        if (finalState.toLowerCase().includes('done') || finalState.toLowerCase().includes('completed')) {
            durations['New'] = Math.round(availableDays * 0.10);
            durations['Analysis'] = Math.round(availableDays * 0.15);
            durations['Development'] = Math.round(availableDays * 0.50);
            durations['Review'] = Math.round(availableDays * 0.15);
            durations['Done'] = Math.round(availableDays * 0.10);
        } else {
            // For other states, distribute more evenly
            durations[finalState] = Math.round(availableDays * 0.70);
            durations['New'] = Math.round(availableDays * 0.15);
            durations['Analysis'] = Math.round(availableDays * 0.15);
        }
        
        return durations;
    }
    
    // Original helper function to estimate state durations (since we don't have transition history)
    function calculateEstimatedStateDurations(totalDays, finalState, isBlocked = false) {
        // Enhanced estimation model that considers blocking impact
        const durations = {};
        
        if (totalDays <= 0) return durations;
        
        // Calculate blocked time more intelligently based on final state
        let availableDays = totalDays;
        let blockedDays = 0;
        
        if (isBlocked) {
            // State-specific blocked time estimation
            switch(finalState.toLowerCase()) {
                case 'development':
                case 'in progress':
                    // Development blocks tend to be longer (25-50% of total time)
                    blockedDays = Math.round(totalDays * (0.25 + Math.random() * 0.25));
                    break;
                case 'analysis':
                case 'review':
                    // Analysis/review blocks are typically shorter (15-35% of total time)
                    blockedDays = Math.round(totalDays * (0.15 + Math.random() * 0.20));
                    break;
                case 'test':
                case 'testing':
                    // Testing blocks are moderate (20-40% of total time)
                    blockedDays = Math.round(totalDays * (0.20 + Math.random() * 0.20));
                    break;
                case 'done':
                case 'completed':
                    // If it's done but was blocked, assume blocking happened earlier
                    // Distribute blocked time across the development phase
                    blockedDays = Math.round(totalDays * 0.30);
                    break;
                default:
                    // Default estimation (20-40% of time was spent blocked)
                    blockedDays = Math.round(totalDays * (0.20 + Math.random() * 0.20));
            }
            
            // Ensure blocked days don't exceed 80% of total time
            blockedDays = Math.min(blockedDays, Math.round(totalDays * 0.8));
            availableDays = totalDays - blockedDays;
            durations['Blocked'] = blockedDays;
        }
        
        // Apply pattern based on final state for remaining time
        if (finalState.toLowerCase().includes('done') || finalState.toLowerCase().includes('completed')) {
            durations['New'] = Math.round(availableDays * 0.10);
            durations['Analysis'] = Math.round(availableDays * 0.15);
            durations['Development'] = Math.round(availableDays * 0.50);
            durations['Review'] = Math.round(availableDays * 0.15);
            durations['Done'] = Math.round(availableDays * 0.10);
        } else {
            // For other states, distribute more evenly
            durations[finalState] = Math.round(availableDays * 0.70);
            durations['New'] = Math.round(availableDays * 0.15);
            durations['Analysis'] = Math.round(availableDays * 0.15);
        }
        
        return durations;
    }
    
    // Get all quarters and states for the chart
    const allQuarterKeys = Object.keys(quarterlyClosedData).sort();
    const allStatesInClosed = new Set();
    
    // Collect all states from the quarterly data
    Object.values(quarterlyClosedData).forEach(qData => {
        Object.keys(qData.statesDuration).forEach(state => allStatesInClosed.add(state));
    });
    const quarterlyUniqueStates = Array.from(allStatesInClosed);
    
    // Create datasets for closed count (bars)
    const closedCountDataset = {
        label: 'PBI\'s Closed',
        type: 'bar',
        data: allQuarterKeys.map(quarter => quarterlyClosedData[quarter].totalClosed),
        // Much lighter fill to reduce intensity
        backgroundColor: 'rgba(52, 152, 219, 0.15)',
        borderColor: 'rgba(52, 152, 219, 0.0)',
        borderWidth: 0,
        barPercentage: 0.8,
        categoryPercentage: 0.8,
        // Draw behind lines and start hidden (user can toggle from legend)
        order: 1,
        hidden: true,
        yAxisID: 'y'
    };
    
    // Create datasets for average state durations (lines)
    const stateDurationDatasets = quarterlyUniqueStates.map((state, index) => {
        // Special handling for blocked state - make it red and more prominent
        let color, borderWidth, pointRadius;
        
        if (state.toLowerCase() === 'blocked') {
            color = '#E74C3C'; // Red for blocked
            borderWidth = 4;    // Thicker line
            pointRadius = 8;    // Larger points
        } else {
            const colors = ['#27AE60', '#F39C12', '#9B59B6', '#1ABC9C', '#34495E', '#E67E22', '#3498DB'];
            color = colors[index % colors.length];
            borderWidth = 3;
            pointRadius = 6;
        }
        
        return {
            label: `Avg Days in ${state}`,
            type: 'line',
            data: allQuarterKeys.map(quarter => {
                const qData = quarterlyClosedData[quarter];
                const stateData = qData.statesDuration[state];
                return stateData ? (stateData.totalDays / stateData.count).toFixed(1) : 0;
            }),
            borderColor: color,
            backgroundColor: color + '20',
            borderWidth: borderWidth,
            pointRadius: pointRadius,
            pointHoverRadius: pointRadius + 2,
            pointBackgroundColor: color,
            pointBorderColor: '#FFFFFF',
            pointBorderWidth: 2,
            // Ensure lines draw above the (very light) bars
            order: 2,
            yAxisID: 'y1',
            tension: 0.4
        };
    });
    
    const quarterlyClosedCtx = document.getElementById('quarterlyClosedChart').getContext('2d');
    registerChart('quarterlyClosedChart', new Chart(quarterlyClosedCtx, {
        type: 'bar',
        data: {
            labels: allQuarterKeys,
            datasets: [closedCountDataset, ...stateDurationDatasets]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Quarterly Analysis: Closed PBI\'s Count & Average State Duration (Red Line = Actual Blocked Days)',
                    font: { size: 16, weight: 'bold' },
                    color: '#2C3E50'
                },
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        font: { size: 11 },
                        color: '#2C3E50'
                    }
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            const quarter = context[0].label;
                            const qData = quarterlyClosedData[quarter];
                            return [`Quarter: ${quarter}`, `Total Closed: ${qData ? qData.totalClosed : 0} PBI's`];
                        },
                        label: function(context) {
                            const datasetLabel = context.dataset.label;
                            const value = context.parsed.y;
                            
                            if (datasetLabel.includes('Closed')) {
                                return `${datasetLabel}: ${value} PBI's`;
                            } else {
                                return `${datasetLabel}: ${value} days`;
                            }
                        },
                        afterBody: function(context) {
                            const quarter = context[0].label;
                            const qData = quarterlyClosedData[quarter];
                            if (qData) {
                                const avgTotalDuration = qData.pbiCount > 0 ? 
                                    (qData.totalDurationAcrossStates / qData.pbiCount).toFixed(1) : 0;
                                
                                let result = [`Overall Avg Duration: ${avgTotalDuration} days`];
                                
                                // Add actual blocked state information if available
                                if (qData.blockedInfo.blockedCount > 0) {
                                    const avgActualBlockedDays = (qData.blockedInfo.totalBlockedDays / qData.blockedInfo.blockedCount).toFixed(1);
                                    const blockedPercentage = ((qData.blockedInfo.blockedCount / qData.totalClosed) * 100).toFixed(1);
                                    result.push(`Blocked PBI's: ${qData.blockedInfo.blockedCount} (${blockedPercentage}%)`);
                                    result.push(`Actual Avg Blocked Days: ${avgActualBlockedDays} days`);
                                    result.push(`(Based on DEBLOCKED=TRUE entries)`);
                                }
                                
                                return result;
                            }
                            return [];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Quarter',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    grid: {
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: {
                        display: true,
                        text: 'Number of PBI\'s Closed',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: {
                        display: true,
                        text: 'Average Days in State',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    beginAtZero: true,
                    grid: {
                        drawOnChartArea: false,
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                }
            }
        }
    }));
    
    // Features Created per Quarter (based on Created Date)
    const allFeatures = uniqueData.filter(row => (row['Work Item Type'] || '').toLowerCase() === 'feature');
    const featuresByQuarter = groupBy(allFeatures, row => parseQuarter(row['Created Date']));
    const featureQuarterKeys = Object.keys(featuresByQuarter).filter(k => k && k !== 'QNaN undefined').sort((a, b) => {
        // Sort by year then quarter
        const [qa, ya] = a.split(' '); // e.g., 'Q3 2025'
        const [qb, yb] = b.split(' ');
        const ia = parseInt(ya, 10), ib = parseInt(yb, 10);
        const qaNum = parseInt(qa.replace('Q',''), 10), qbNum = parseInt(qb.replace('Q',''), 10);
        return ia === ib ? qaNum - qbNum : ia - ib;
    });
    
    const featuresPerQuarterCtx = document.getElementById('featuresPerQuarterChart').getContext('2d');
    registerChart('featuresPerQuarterChart', new Chart(featuresPerQuarterCtx, {
        type: 'bar',
        data: {
            labels: featureQuarterKeys,
            datasets: [{
                label: 'Features Created',
                data: featureQuarterKeys.map(k => (featuresByQuarter[k] || []).length),
                backgroundColor: 'rgba(52, 152, 219, 0.7)',
                borderColor: '#3498DB',
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Features Created per Quarter (by Created Date)',
                    font: { size: 16, weight: 'bold' },
                    color: '#2C3E50'
                },
                legend: { display: false },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: function(context) { return `Quarter: ${context[0].label}`; },
                        label: function(context) { return `Features: ${context.parsed.y}`; }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Quarter', font: { size: 14, weight: 'bold' } },
                    grid: { display: false }
                },
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Count', font: { size: 14, weight: 'bold' } }
                }
            }
        }
    }));
    
    // Populate Features table (basic details, most recent first by Created Date)
    const parseDateSafe = (d) => {
        if (!d) return null;
        const clean = String(d).split(' ')[0];
        const parts = clean.split('/');
        if (parts.length === 3) return new Date(parts[2], parts[0]-1, parts[1]);
        const dt = new Date(clean);
        return isNaN(dt) ? null : dt;
    };
    const featuresSorted = allFeatures
        .map(f => ({
            id: f['Work Item Id'] || f['ID'] || '',
            title: f['Title'] || '',
            created: f['Created Date'] || '',
            state: f['State'] || 'Unknown',
            assignee: f['Assigned To'] || 'Unassigned',
            sortDate: parseDateSafe(f['Created Date']) || new Date(0)
        }))
        .sort((a, b) => b.sortDate - a.sortDate);
    const featuresTbody = document.querySelector('#featuresTable tbody');
    featuresTbody.innerHTML = featuresSorted.map(f => `
        <tr>
            <td>${f.id}</td>
            <td title="${f.title}">${f.title.substring(0, 100)}${f.title.length > 100 ? 'â€¦' : ''}</td>
            <td>${f.created ? String(f.created).split(' ')[0] : ''}</td>
            <td><span class="badge ${f.state === 'Done' ? 'bg-success' : 'bg-secondary'}">${f.state}</span></td>
            <td>${f.assignee}</td>
        </tr>
    `).join('');
    
    // Ticket state pie chart with semantic colors
    const tspCtx = document.getElementById('ticketStatePieChart').getContext('2d');
    
    // Create color mapping based on state names
    const stateLabels = Object.keys(stateCounts);
    const pieStateColors = stateLabels.map(state => {
        const lowerState = state.toLowerCase();
        if (lowerState.includes('done') || lowerState.includes('completed') || lowerState.includes('closed')) {
            return '#27AE60'; // Green for completed states
        } else if (lowerState.includes('blocked')) {
            return '#E74C3C'; // Red for blocked states
        } else if (lowerState.includes('progress') || lowerState.includes('development') || lowerState.includes('active')) {
            return '#3498DB'; // Blue for active work
        } else if (lowerState.includes('review') || lowerState.includes('testing') || lowerState.includes('test')) {
            return '#9B59B6'; // Purple for review/testing
        } else if (lowerState.includes('analysis') || lowerState.includes('planning')) {
            return '#F39C12'; // Orange for analysis/planning
        } else if (lowerState.includes('new') || lowerState.includes('open') || lowerState.includes('todo')) {
            return '#95A5A6'; // Gray for new/open items
        } else {
            return '#34495E'; // Dark gray for unknown states
        }
    });
    
    console.log('State color mapping:', stateLabels.map((label, i) => ({ state: label, color: pieStateColors[i] })));
    
    registerChart('ticketStatePieChart', new Chart(tspCtx, {
        type: 'pie',
        data: {
            labels: stateLabels,
            datasets: [{
                data: Object.values(stateCounts),
                backgroundColor: pieStateColors,
                borderColor: '#FFFFFF',
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        usePointStyle: true,
                        generateLabels: function(chart) {
                            const data = chart.data;
                            return data.labels.map((label, i) => ({
                                text: `${label} (${data.datasets[0].data[i]})`,
                                fillStyle: data.datasets[0].backgroundColor[i],
                                strokeStyle: data.datasets[0].borderColor,
                                lineWidth: data.datasets[0].borderWidth,
                                pointStyle: 'circle'
                            }));
                        }
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const label = context.label || '';
                            const value = context.parsed;
                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                            const percentage = ((value / total) * 100).toFixed(1);
                            return `${label}: ${value} tickets (${percentage}%)`;
                        }
                    }
                }
            }
        }
    }));
    // Ticket type pie chart
    const ttpCtx = document.getElementById('ticketTypePieChart').getContext('2d');
    registerChart('ticketTypePieChart', new Chart(ttpCtx, {
        type: 'pie',
        data: {
            labels: Object.keys(typeCounts),
            datasets: [{
                data: Object.values(typeCounts),
                backgroundColor: ['#6610f2','#e83e8c','#fd7e14','#20c997','#6f42c1','#343a40']
            }]
        },
        options: {responsive:true, maintainAspectRatio:false, plugins:{legend:{position:'right'}}}
    }));
    
    // Continue with other existing functionality...
    
    // Blocked state analysis using unique work items (exclude State = "Blocked" since we use DEBLOCKED column)
    const blockedCounts = {};
    const blockedByState = {}; // Track which states have blocked items
    
    const filteredUniqueData = uniqueData.filter(row => {
        const state = row['State'] || '';
        return state.toLowerCase() !== 'blocked'; // Exclude items with State = "Blocked"
    });
    
    filteredUniqueData.forEach(row => {
        const deblocked = row['DEBLOCKED'];
        const currentState = row['State'] || 'Unknown';
        
        // DEBLOCKED = TRUE means the item IS currently blocked
        // DEBLOCKED = FALSE means the item is NOT blocked
        const isBlocked = (deblocked === 'TRUE' || deblocked === true || deblocked === 'True');
        const blockedStatus = isBlocked ? 'Blocked' : 'Not Blocked';
        
        blockedCounts[blockedStatus] = (blockedCounts[blockedStatus] || 0) + 1;
        
        // Track blocked items by state
        if (isBlocked) {
            if (!blockedByState[currentState]) {
                blockedByState[currentState] = { count: 0, totalAge: 0 };
            }
            blockedByState[currentState].count += 1;
            
            // Calculate age for blocked items
            const createdDate = parseDate(row['Created Date']);
            if (createdDate) {
                const ageInDays = Math.floor((todayRef - createdDate) / (1000 * 60 * 60 * 24));
                blockedByState[currentState].totalAge += ageInDays;
            }
        }
    });
    
    const blockedRows = Object.entries(blockedCounts).map(([status, count]) => ({
        status: status,
        count: count,
        percentage: ((count / filteredUniqueData.length) * 100).toFixed(1)
    }));
    
    // Add blocked by state information to the blocked table
    const blockedByStateRows = Object.entries(blockedByState).map(([state, data]) => ({
        status: `${state} (Blocked)`,
        count: data.count,
        percentage: ((data.count / uniqueData.length) * 100).toFixed(1),
        avgAge: data.count > 0 ? (data.totalAge / data.count).toFixed(1) : '0'
    }));
    
    const blockedBody = document.querySelector('#blockedStateTable tbody');
    
    // Combine overall blocked counts with state-specific blocked information
    const allBlockedRows = [
        ...blockedRows,
        ...blockedByStateRows
    ];
    
    blockedBody.innerHTML = allBlockedRows.map(row => {
        const isStateSpecific = row.status.includes('(Blocked)');
        const rowClass = isStateSpecific ? 'table-warning' : '';
        const avgAgeColumn = row.avgAge ? `<td>${row.avgAge} days</td>` : '<td>-</td>';
        
        return `<tr class="${rowClass}">
            <td>${row.status}</td>
            <td>${row.count}</td>
            <td>${row.percentage}%</td>
            ${avgAgeColumn}
        </tr>`;
    }).join('');
    
    // Feature Details section removed per request.
    // Tickets closed by type using unique work items
    const ticketsByType = {};
    uniqueData.filter(row => row['State'] === 'Done').forEach(row => {
        const type = row['Work Item Type'] || 'Unknown';
        ticketsByType[type] = (ticketsByType[type] || 0) + 1;
    });
    
    // Removed age distribution & average age by state charts per request.

    // Build state durations & blocked days per work item for enhanced scatter tooltip
    const stateDurationsMap = {};
    const rowsById = {};
    data.forEach(r => {
        const id = r['Work Item Id'] || r['ID'] || r['Id'];
        if (!id) return;
        if (!rowsById[id]) rowsById[id] = [];
        rowsById[id].push(r);
    });
    // Use existing todayRef for consistency
    const todayLocal = todayRef;
    Object.entries(rowsById).forEach(([id, rows]) => {
        // Sort by State Change Date then Created Date
        rows.sort((a,b) => {
            const da = new Date(a['State Change Date'] || a['Changed Date'] || a['Created Date'] || a['CreatedDate'] || a['ChangedDate'] || todayLocal);
            const db = new Date(b['State Change Date'] || b['Changed Date'] || b['Created Date'] || b['CreatedDate'] || b['ChangedDate'] || todayLocal);
            return da - db;
        });
        const timeline = [];
        const seen = new Set();
        rows.forEach(row => {
            const state = row['State'] || 'Unknown';
            const dateStr = row['State Change Date'] || row['Changed Date'] || row['ChangedDate'] || row['Created Date'] || row['CreatedDate'];
            if (!dateStr) return;
            const dt = new Date(dateStr);
            if (isNaN(dt)) return;
            // Add every occurrence that represents a change (first time we see state or different from last)
            if (timeline.length === 0 || timeline[timeline.length-1].state !== state) {
                timeline.push({ state, date: dt });
            }
            seen.add(state);
        });
        if (timeline.length === 0) return;
        const durations = [];
        for (let i=0; i<timeline.length; i++) {
            const cur = timeline[i];
            const next = timeline[i+1];
        const endDate = next ? next.date : todayRef;
            const days = Math.max(0, Math.round((endDate - cur.date)/(1000*60*60*24)));
            durations.push({ state: cur.state, days });
        }
        const totalAge = durations.reduce((s,d)=>s+d.days,0);
        const blockedDays = rows.filter(r => {
            const val = r['DEBLOCKED'] || r['Deblocked'] || r['deblocked'];
            return val === true || String(val).toLowerCase() === 'true' || val === 1 || val === '1';
        }).length; // assuming each row ~ daily snapshot
        stateDurationsMap[id] = {
            durations,
            totalAge,
            blockedDays,
            statesTraversed: durations.length,
            currentState: durations[durations.length-1]?.state || 'Unknown'
        };
    });
    
    // Aging Scatter Chart - State vs Age with blocked highlighting (Product Backlog Items only)
    const scatterData = [];
    const statePositions = {}; // Map states to x-axis positions
    
    // Filter for Product Backlog Items only, excluding items with State = "Blocked"
    // (We use DEBLOCKED column for blocking representation instead)
    const productBacklogItems = openUniqueTicketsWithAge.filter(ticket => {
        const workItemType = ticket['Work Item Type'] || '';
        const state = ticket['State'] || '';
        return workItemType === 'Product Backlog Item' && state.toLowerCase() !== 'blocked';
    });
    
    const uniqueStates = [...new Set(productBacklogItems.map(ticket => ticket['State'] || 'Unknown'))].sort();
    
    // Assign x-axis positions to states
    uniqueStates.forEach((state, index) => {
        statePositions[state] = index;
    });
    
    // Enhanced state colors for scatter plot (Blocked is NOT a state - it's a condition)
    const scatterStateColors = {
        'In Progress': '#3498db',
        'Development': '#e74c3c', 
        'Analysis': '#f39c12',
        'Review': '#2ecc71',
        'Test': '#9b59b6',
        'New': '#95a5a6',
        'Unknown': '#34495e'
    };
    
    // Simplified function to get color - only two colors: default blue and red for blocked
    function getScatterColor(ticket) {
        const isBlocked = (ticket['DEBLOCKED'] === true) || (String(ticket['DEBLOCKED']).toLowerCase() === 'true');

        if (isBlocked) {
            return '#E74C3C'; // Red for blocked items
        }

        return '#3498DB'; // Default blue for all non-blocked items
    }
    
    // Prepare scatter plot data (Product Backlog Items only)
    productBacklogItems.forEach(ticket => {
        const state = ticket['State'] || 'Unknown';
        const age = ticket.ageInDays;
        const isBlocked = ticket['DEBLOCKED'] === 'TRUE' || ticket['DEBLOCKED'] === true || ticket['DEBLOCKED'] === 'True';
        
        scatterData.push({
            x: statePositions[state],
            y: age,
            ticket: ticket,
            isBlocked: isBlocked,
            color: getScatterColor(ticket)
        });
    });
    
    // Group data by color for proper rendering - simplified to just two categories
    const scatterDatasets = {};
    scatterData.forEach(point => {
        const color = point.color;
        if (!scatterDatasets[color]) {
            scatterDatasets[color] = {
                label: point.isBlocked ? 'Blocked Items' : 'Regular Items',
                data: [],
                backgroundColor: color,
                borderColor: color,
                pointRadius: point.isBlocked ? 8 : 6,
                pointHoverRadius: point.isBlocked ? 10 : 8,
                showLine: false
            };
        }
        scatterDatasets[color].data.push(point);
    });
    
    const agingScatterCtx = document.getElementById('agingScatterChart').getContext('2d');
    
    // Calculate overall health score based on blocked vs non-blocked items
    const totalItems = productBacklogItems.length;
    let healthScore = 0;
    
    if (totalItems > 0) {
        const blockedTickets = productBacklogItems.filter(ticket => {
            return (ticket['DEBLOCKED'] === true) || (String(ticket['DEBLOCKED']).toLowerCase() === 'true');
        }).length;
        const nonBlockedTickets = totalItems - blockedTickets;
        
        // Calculate health score (0-100): Non-blocked = good, Blocked = bad
        healthScore = (nonBlockedTickets * 100) / totalItems;
        
        console.log(`Health Analysis: ${nonBlockedTickets} non-blocked, ${blockedTickets} blocked tickets. Health Score: ${healthScore.toFixed(1)}`);
    }
    
    // Determine background color based on health score
    let backgroundColor;
    if (healthScore >= 75) {
        backgroundColor = 'rgba(39, 174, 96, 0.15)'; // Strong green background - healthy situation
    } else if (healthScore >= 50) {
        backgroundColor = 'rgba(46, 204, 113, 0.12)'; // Light green background - mostly healthy
    } else if (healthScore >= 35) {
        backgroundColor = 'rgba(241, 196, 15, 0.12)'; // Yellow background - mixed situation
    } else if (healthScore >= 20) {
        backgroundColor = 'rgba(243, 156, 18, 0.15)'; // Orange background - concerning
    } else {
        backgroundColor = 'rgba(231, 76, 60, 0.15)'; // Red background - critical situation
    }
    
    // Set the canvas background color
    agingScatterCtx.canvas.style.backgroundColor = backgroundColor;
    
    registerChart('agingScatterChart', new Chart(agingScatterCtx, {
        type: 'scatter',
        data: {
            datasets: Object.values(scatterDatasets)
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
            interaction: { mode: 'nearest', intersect: true },
            layout: { padding: { top: 8, right: 12, bottom: 8, left: 12 } },
            elements: { point: { hitRadius: 12, hoverRadius: 10 } },
            scales: {
                x: {
                    type: 'linear',
                    position: 'bottom',
                    min: -0.5,
                    max: uniqueStates.length - 0.5,
                    ticks: {
                        stepSize: 1,
                        callback: function(value) {
                            return uniqueStates[Math.round(value)] || '';
                        }
                    },
                    title: {
                        display: true,
                        text: 'Ticket State',
                        font: { size: 14, weight: 'bold' }
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Age (Days)',
                        font: { size: 14, weight: 'bold' }
                    },
                    grid: {
                        color: function(context) {
                            // Safe access to tick value
                            const value = context?.tick?.value;
                            if (typeof value !== 'number') return 'rgba(0, 0, 0, 0.1)';
                            
                            // Enhanced grid lines at age thresholds
                            if (value === 25) {
                                return 'rgba(39, 174, 96, 0.6)'; // Green line at 25 days
                            }
                            if (value === 60) {
                                return 'rgba(243, 156, 18, 0.6)'; // Orange line at 60 days
                            }
                            if ([90, 120].includes(value)) {
                                return 'rgba(231, 76, 60, 0.5)'; // Red lines at high age thresholds
                            }
                            // Subtle gradient for other grid lines
                            if (value <= 25) {
                                return 'rgba(39, 174, 96, 0.2)'; // Light green grid for recent zone
                            } else if (value <= 60) {
                                return 'rgba(243, 156, 18, 0.2)'; // Light orange grid for moderate zone
                            } else {
                                return 'rgba(231, 76, 60, 0.2)'; // Light red grid for old zone
                            }
                        },
                        lineWidth: function(context) {
                            // Safe access to tick value
                            const value = context?.tick?.value;
                            if (typeof value !== 'number') return 1;
                            
                            // Thicker lines at key thresholds
                            if ([25, 60].includes(value)) {
                                return 2;
                            }
                            return 1;
                        }
                    },
                    ticks: {
                        color: function(context) {
                            // Safe access to tick value
                            const value = context?.tick?.value;
                            if (typeof value !== 'number') return '#000000';
                            
                            // Color-code the age labels
                            if (value <= 25) {
                                return '#27AE60'; // Green for recent
                            } else if (value <= 60) {
                                return '#F39C12'; // Orange for moderate
                            } else {
                                return '#E74C3C'; // Red for old
                            }
                        },
                        font: {
                            weight: function(context) {
                                // Safe access to tick value
                                const value = context?.tick?.value;
                                if (typeof value !== 'number') return 'normal';
                                
                                // Bold font for key thresholds
                                if ([25, 60].includes(value)) {
                                    return 'bold';
                                }
                                return 'normal';
                            }
                        }
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        filter: function(legendItem) {
                            // Show Blocked and all non-blocked age bands
                            return legendItem.text.includes('Blocked') || 
                                   legendItem.text.includes('â‰¤25 days') || 
                                   legendItem.text.includes('26-60 days') ||
                                   legendItem.text.includes('>60 days');
                        }
                    }
                },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: function(tooltipItems) {
                            const p = tooltipItems[0];
                            const found = scatterData.find(d => d.x === p.parsed.x && d.y === p.parsed.y);
                            if (!found) return '';
                            return `ID: ${found.ticket['Work Item Id'] || 'N/A'}`;
                        },
                        label: function(ctx) {
                            const found = scatterData.find(d => d.x === ctx.parsed.x && d.y === ctx.parsed.y);
                            if (!found) return '';
                            const t = found.ticket;
                            const id = t['Work Item Id'];
                            const sd = stateDurationsMap[id] || {};
                            const durations = sd.durations || [];
                            const title = t['Title'] ? (t['Title'].length>70 ? t['Title'].substring(0,67)+'...' : t['Title']) : 'No Title';
                            const developer = t['Assigned To'] || 'Unassigned';
                            const blocked = sd.blockedDays ?? 0;
                            const lines = [];
                            lines.push(`Title: ${title}`);
                            lines.push(`Current State: ${(sd.currentState||t['State']||'Unknown')}${found.isBlocked?' (BLOCKED)':''}`);
                            lines.push(`Developer: ${developer}`);
                            lines.push(`Total Age: ${t.ageInDays} days`);
                            lines.push(`Blocked Days: ${blocked}`);
                            lines.push(`States Traversed: ${sd.statesTraversed || durations.length}`);
                            durations.slice(0,10).forEach(d => {
                                lines.push(` - ${d.state}: ${d.days}d`);
                            });
                            if (durations.length>10) lines.push(` - (+${durations.length-10} more)`);
                            return lines;
                        }
                    }
                }
            },
            layout: {
                padding: 20
            }
        }
    }));
    
    // Update health indicator display
    const healthIndicator = document.getElementById('healthIndicator');
    if (totalItems > 0) {
        const blockedTickets = productBacklogItems.filter(ticket => 
            ticket['DEBLOCKED'] === 'TRUE' || ticket['DEBLOCKED'] === true || ticket['DEBLOCKED'] === 'True'
        ).length;
        const nonBlockedTickets = totalItems - blockedTickets;
        
        let healthMessage, healthClass, borderColor;
        
        if (healthScore >= 90) {
            healthMessage = `ðŸŸ¢ EXCELLENT Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-success';
            borderColor = '#27AE60';
        } else if (healthScore >= 75) {
            healthMessage = `ðŸŸ¡ GOOD Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-info';
            borderColor = '#2ECC71';
        } else if (healthScore >= 50) {
            healthMessage = `ðŸŸ  MODERATE Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-warning';
            borderColor = '#F1C40F';
        } else if (healthScore >= 25) {
            healthMessage = `ðŸŸ  CONCERNING Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-warning';
            borderColor = '#F39C12';
        } else {
            healthMessage = `ðŸ”´ CRITICAL Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-danger';
            borderColor = '#E74C3C';
        }
        
        healthIndicator.className = `alert ${healthClass}`;
        healthIndicator.style.borderLeftColor = borderColor;
        healthIndicator.innerHTML = `
            <strong>${healthMessage}</strong><br>
            <small>
                ðŸ“Š Status Distribution: 
                <span class="badge bg-primary">${nonBlockedTickets} Regular Items</span>
                <span class="badge bg-danger">${blockedTickets} Blocked Items</span>
                | <strong>Total: ${totalItems} Product Backlog Items</strong>
            </small>
        `;
    } else {
        healthIndicator.className = 'alert alert-secondary';
        healthIndicator.innerHTML = '<strong>No Product Backlog Items found</strong>';
    }
    
    // Aging Distribution Matrix and Oldest Open PBI logic removed (cleanup of dangling references to ageHistLabels).
    
}
document.getElementById('csvFileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    // Show loading indicator
    document.getElementById('kpiSection').innerHTML = '<div class="col-12 text-center"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div><p>Processing CSV file...</p></div>';
    
    Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: function(results) {
            if (results.errors.length > 0) {
                console.error('CSV parsing errors:', results.errors);
                document.getElementById('kpiSection').innerHTML = '<div class="col-12 alert alert-danger">CSV parsing errors: ' + results.errors.map(e => e.message).join(', ') + '</div>';
                return;
            }
            
            if (results.data.length === 0) {
                document.getElementById('kpiSection').innerHTML = '<div class="col-12 alert alert-warning">No data found in CSV file</div>';
                return;
            }
            
            try {
                updateDashboard(results.data);
            } catch (error) {
                console.error('Error updating dashboard:', error);
                document.getElementById('kpiSection').innerHTML = '<div class="col-12 alert alert-danger">Error processing data: ' + error.message + '</div>';
            }
        },
        error: function(error) {
            console.error('Papa.parse error:', error);
            document.getElementById('kpiSection').innerHTML = '<div class="col-12 alert alert-danger">Error parsing CSV: ' + error.message + '</div>';
        }
    });
});
</script>
</body>
</html>

