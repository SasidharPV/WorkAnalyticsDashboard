<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Work Item Analytics Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        // Ensure Chart.js defaults don't disable tooltips
        if (typeof Chart !== 'undefined') {
            Chart.defaults.plugins.tooltip = Chart.defaults.plugins.tooltip || {};
            Chart.defaults.plugins.tooltip.enabled = true;
            Chart.defaults.interaction = Chart.defaults.interaction || {};
            Chart.defaults.interaction.intersect = false;
            Chart.defaults.interaction.mode = 'nearest';
            Chart.defaults.events = ['mousemove','mouseout','click','touchstart','touchmove','touchend'];
        }

        // Helper to guard tooltip callbacks from errors
        function safe(cb, fallback) {
            return function() {
                try { return cb.apply(this, arguments); }
                catch (err) { console.error('Tooltip callback error:', err); return fallback; }
            };
        }
    </script>
    <style>
        body { background: #f8f9fa; }
        .dashboard-section { margin-bottom: 2rem; }
        .chart-container { 
            min-height: 350px; 
            position: relative;
        }
        canvas { 
            position: relative !important;
            z-index: 1 !important;
            pointer-events: auto; /* ensure hover/click are captured */
        }
        .kpi { font-size: 1.5rem; font-weight: bold; }
        .table-responsive { max-height: 400px; overflow-y: auto; }
        .border-left-warning { border-left: 4px solid #f39c12; }
        
        /* Print styles for browser printing */
        @media print {
            body { background: white !important; font-size: 12px; }
            .dashboard-section { margin-bottom: 1.5rem; page-break-inside: avoid; }
            .chart-container { min-height: 280px; max-height: 320px; page-break-inside: avoid; }
            .table-responsive { max-height: none; overflow: visible; page-break-inside: avoid; }
            .kpi { font-size: 1.2rem; }
            h1 { font-size: 1.8rem; }
            h3 { font-size: 1.4rem; margin-bottom: 1rem; }
            .table { font-size: 11px; }
        }
    </style>
</head>
<body>
<div class="container py-4" id="dashboard">
    <h1 class="mb-4 text-center">Work Item Analytics Dashboard</h1>
    <div class="mb-3">
        <input type="file" id="csvFileInput" accept=".csv" class="form-control">
    </div>
    <div id="kpiSection" class="dashboard-section row text-center"></div>
    
    <!-- Blocked Items Summary Section -->
    <div id="blockedSummarySection" class="dashboard-section" style="display: none;">
        <div class="alert alert-warning border-left-warning">
            <h4 class="alert-heading">ðŸš« Blocked Items Summary</h4>
            <div class="row" id="blockedSummaryContent">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>
    
    <div class="dashboard-section row">
        <div class="col-md-6 chart-container">
            <canvas id="ticketsPerPersonChart"></canvas>
        </div>
        <div class="col-md-6 chart-container">
            <canvas id="ticketsOverTimeChart"></canvas>
        </div>
    </div>
    <div class="dashboard-section row">
        <div class="col-md-6 chart-container">
            <canvas id="ticketStatePieChart"></canvas>
        </div>
        <div class="col-md-6 chart-container">
            <canvas id="ticketTypePieChart"></canvas>
        </div>
    </div>

    <div class="dashboard-section">
        <h3>PBI's by Blocked State</h3>
        <div class="alert alert-info mb-3">
            <strong>Note:</strong> Items with <code>DEBLOCKED = TRUE</code> are currently <strong>blocked</strong>. 
            Items with <code>DEBLOCKED = FALSE</code> are <strong>not blocked</strong>.<br>
            <strong>Important:</strong> Items with State = "Blocked" are excluded from analysis since we use the DEBLOCKED column for blocking representation.
            The table below shows blocking status based on the DEBLOCKED column only.
        </div>
        <div class="table-responsive">
            <table class="table table-striped" id="blockedStateTable">
                <thead><tr><th>Blocked Status</th><th>Count</th><th>Percentage</th><th>Avg Age (Blocked Items)</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    <div class="dashboard-section">
        <h3>Feature Details - Implemented & In Progress</h3>
        <div class="table-responsive">
            <table class="table table-striped" id="featureDetailsTable">
                <thead><tr><th>ID</th><th>Title</th><th>Status</th><th>Developer</th><th>Created Date</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <div class="dashboard-section row">
        <div class="col-md-6 chart-container">
            <h3>PBI Age Distribution (Open PBI's)</h3>
            <canvas id="ticketAgeHistogram"></canvas>
        </div>
        <div class="col-md-6 chart-container">
            <h3>Average Age by State (Open PBI's)</h3>
            <canvas id="ageByStateChart"></canvas>
        </div>
    </div>
    
    <div class="dashboard-section">
        <h3>Product Backlog Items - Aging Scatter Plot (State vs Age)</h3>
        <div class="chart-container">
            <canvas id="agingScatterChart"></canvas>
        </div>
        <div class="row mt-3">
            <div class="col-md-12">
                <div class="alert alert-info">
                    <strong>Product Backlog Items Only:</strong> 
                    <span class="badge bg-danger me-2">Red = Blocked (DEBLOCKED = TRUE)</span>
                    <span class="badge bg-primary me-2">Blue = Regular Items (DEBLOCKED = FALSE)</span>
                    <br><small>Only Product Backlog Items are shown. Simple color coding: Red for blocked items, Blue for all other items.</small>
                </div>
                <div id="healthIndicator" class="alert" style="border-left: 5px solid; margin-top: 10px;">
                    <!-- Health indicator will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>
    
    <div class="dashboard-section">
        <h3>PBI Inflow vs Outflow Trends</h3>
        <div class="chart-container">
            <canvas id="inflowOutflowChart"></canvas>
        </div>
    </div>
    
    <div class="dashboard-section">
        <h3>Monthly Developer Performance Heatmap</h3>
    <div class="chart-container" style="min-height: 620px;">
            <canvas id="developerHeatmapChart"></canvas>
        </div>
    </div>
    
    <div class="dashboard-section">
        <h3>Quarterly Closed PBI's & Average State Duration</h3>
        <div class="chart-container">
            <canvas id="quarterlyClosedChart"></canvas>
        </div>
        <div class="alert alert-info mt-3">
            <strong>ðŸ“Š Blocked Duration Calculation:</strong> The red "Blocked" line shows the actual average number of days that PBI's were blocked (DEBLOCKED = TRUE) during their lifecycle. 
            This is calculated by counting all historical entries where DEBLOCKED = TRUE for each work item, providing real blocked time data rather than estimates.
        </div>
    </div>
    
    <div class="dashboard-section">
        <h3>Features Created per Quarter</h3>
        <div class="chart-container">
            <canvas id="featuresPerQuarterChart"></canvas>
        </div>
        <div class="table-responsive mt-3">
            <table class="table table-striped" id="featuresTable">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Title</th>
                        <th>Created Date</th>
                        <th>State</th>
                        <th>Assigned To</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
    <div class="dashboard-section">
        <h3>Aging Distribution Matrix: Age Ranges vs States (Open PBI's)</h3>
        <div class="chart-container">
            <canvas id="agingByStateChart"></canvas>
        </div>
    </div>
    
    <div class="dashboard-section">
        <h3>Oldest Open PBI's by Developer</h3>
        <div class="table-responsive">
            <table class="table table-striped" id="agingTicketsTable">
                <thead><tr><th>ID</th><th>Title</th><th>Developer</th><th>State</th><th>Age (Days)</th><th>Start Date</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <div class="dashboard-section">
        <h3>Developer Completion Time Analysis (Business Days, Excluding Blocked Time)</h3>
        <div class="table-responsive">
            <table class="table table-striped" id="developerCompletionTable">
                <thead>
                    <tr>
                        <th>PBI ID</th>
                        <th>Title</th>
                        <th>Developer</th>
                        <th>Current State</th>
                        <th>Blocked Status</th>
                        <th>Start Date</th>
                        <th>Closed Date</th>
                        <th>Total Days</th>
                        <th>Business Days</th>
                        <th>Est. Blocked Days</th>
                        <th>Net Work Days</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>
<script>
function parseQuarter(dateStr) {
    if (!dateStr) return '';
    const cleanStr = String(dateStr).replace(/\"/g, '').trim();
    const [datePart] = cleanStr.split(' '); // Take only date part, ignore time
    if (!datePart || !datePart.includes('/')) return '';
    const parts = datePart.split('/');
    if (parts.length !== 3) return '';
    // CSV uses MM/DD/YYYY
    const [mm, dd, yyyy] = parts.map(p => p.trim());
    const m = parseInt(mm, 10);
    const y = parseInt(yyyy, 10);
    if (!m || !y) return '';
    const q = Math.floor((m - 1) / 3) + 1;
    return `Q${q} ${y}`;
}
function daysBetween(start, end) {
    if (!start || !end) {
        return null;
    }
    
    // Parse dates in MM/DD/YYYY format (consistent with temp2.csv)
    const parseDate = (dateStr) => {
        try {
            const cleanStr = String(dateStr).replace(/\"/g, '').trim();
            
            // Handle different date formats
            let datePart;
            if (cleanStr.includes(' ')) {
                [datePart] = cleanStr.split(' '); // Take only date part, ignore time
            } else {
                datePart = cleanStr;
            }
            
            // Use MM/DD/YYYY format (based on temp2.csv format)
            if (datePart.includes('/')) {
                const parts = datePart.split('/');
                if (parts.length === 3) {
                    const [month, day, year] = parts;
                    const parsedDate = new Date(year, month - 1, day);
                    return parsedDate;
                }
            }
            
            // Try other formats
            const fallbackDate = new Date(cleanStr);
            return fallbackDate;
        } catch (error) {
            console.error('Date parsing error:', error, 'Input:', dateStr);
            return null;
        }
    };
    
    const s = parseDate(start);
    const e = parseDate(end);
    
    if (!s || !e || isNaN(s) || isNaN(e)) {
        return null;
    }
    
    const diffTime = e - s;
    const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
    
    return diffDays;
}

// Calculate business days between two dates (excluding weekends)
function businessDaysBetween(startDate, endDate) {
    if (!startDate || !endDate) return null;
    
    const parseDate = (dateStr) => {
        try {
            const cleanStr = String(dateStr).replace(/\"/g, '').trim();
            let datePart;
            if (cleanStr.includes(' ')) {
                [datePart] = cleanStr.split(' ');
            } else {
                datePart = cleanStr;
            }
            
            if (datePart.includes('/')) {
                const parts = datePart.split('/');
                if (parts.length === 3) {
                    const [month, day, year] = parts;
                    return new Date(year, month - 1, day);
                }
            }
            return new Date(cleanStr);
        } catch (error) {
            console.error('Date parsing error in businessDaysBetween:', error);
            return null;
        }
    };
    
    const start = parseDate(startDate);
    const end = parseDate(endDate);
    
    if (!start || !end || isNaN(start) || isNaN(end)) return null;
    
    let businessDays = 0;
    const current = new Date(start);
    
    while (current <= end) {
        const dayOfWeek = current.getDay();
        // 0 = Sunday, 6 = Saturday
        if (dayOfWeek !== 0 && dayOfWeek !== 6) {
            businessDays++;
        }
        current.setDate(current.getDate() + 1);
    }
    
    return Math.max(0, businessDays - 1); // Subtract 1 to exclude the start date
}
function groupBy(arr, keyFn) {
    return arr.reduce((acc, item) => {
        const key = keyFn(item);
        acc[key] = acc[key] || [];
        acc[key].push(item);
        return acc;
    }, {});
}
function updateDashboard(data) {
    // Current date for comparison
    const today = new Date();
    const todayStr = today.toLocaleDateString('en-GB'); // DD/MM/YYYY format
    
    // Helper function to parse dates in MM/DD/YYYY format (based on temp2.csv format)
    function parseDate(dateStr) {
        if (!dateStr) return null;
        try {
            const cleanStr = String(dateStr).replace(/\"/g, '').trim();
            const [datePart] = cleanStr.split(' '); // Take only date part, ignore time
            
            if (datePart.includes('/')) {
                const parts = datePart.split('/');
                if (parts.length === 3) {
                    // Assume MM/DD/YYYY format based on temp2.csv
                    const [month, day, year] = parts;
                    const parsedDate = new Date(year, month - 1, day);
                    return parsedDate;
                }
            }
            
            // Fallback for other formats
            return new Date(cleanStr);
        } catch (error) {
            console.error('Date parsing error:', error, 'Input:', dateStr);
            return null;
        }
    }
    
    // Helper function to get closed date or use today's date
    function getClosedDate(row) {
        if (row['Closed Date']) {
            const closedDate = parseDate(row['Closed Date']);
            // If closed date is in the future, use today's date instead
            if (closedDate > today) {
                return todayStr;
            }
            return row['Closed Date'];
        }
        return todayStr;
    }
    
    // Deduplicate data by Work Item ID and get the latest state for each work item
    const uniqueWorkItems = {};
    data.forEach(row => {
        const workItemId = row['Work Item Id'] || row['ID'];
        const stateChangeDate = parseDate(row['State Change Date'] || row['Created Date']);
        
        if (!uniqueWorkItems[workItemId] || 
            (stateChangeDate && parseDate(uniqueWorkItems[workItemId]['State Change Date'] || uniqueWorkItems[workItemId]['Created Date']) < stateChangeDate)) {
            uniqueWorkItems[workItemId] = row;
        }
    });
    
    // Convert back to array with unique work items
    const uniqueData = Object.values(uniqueWorkItems);
    // Restrict to Product Backlog Items for PBI-specific metrics and charts
    const pbisUnique = uniqueData.filter(row => (row['Work Item Type'] || '').toLowerCase() === 'product backlog item');
    
    console.log('Original data rows:', data.length);
    console.log('Unique work items after deduplication:', uniqueData.length);
    console.log('Sample unique item:', uniqueData[0]);
    console.log('Done PBI count:', pbisUnique.filter(row => row['State'] === 'Done').length);
    
    // Log first few done tickets for debugging
    const doneTickets = pbisUnique.filter(row => row['State'] === 'Done').slice(0, 3);
    console.log('Sample done tickets:', doneTickets.map(ticket => ({
        id: ticket['Work Item Id'],
        assignedTo: ticket['Assigned To'],
        startDate: ticket['Start Date'],
        closedDate: ticket['Closed Date'],
        stateChangeDate: ticket['State Change Date'],
        createdDate: ticket['Created Date']
    })));
    
    // Filter only Done tickets and apply proper closed date logic
    // Only PBIs are considered "tickets" for PBI-focused visuals
    const closedTickets = pbisUnique.filter(row => row['State'] === 'Done').map(row => {
        return { ...row, 'Closed Date': getClosedDate(row) };
    });
    
    // KPIs using unique work items
    const totalTickets = pbisUnique.length;
    const totalClosed = closedTickets.length;
    const people = [...new Set(pbisUnique.map(row => row['Assigned To']))].filter(Boolean);
    const avgClosedPerPerson = people.length > 0 ? (totalClosed / people.length).toFixed(2) : '0';
    
    // Debug calculations
    console.log('=== KPI CALCULATIONS DEBUG ===');
    console.log('Total unique work items:', totalTickets);
    console.log('Total closed PBIs:', totalClosed);
    console.log('Number of people:', people.length);
    console.log('People list:', people);
    console.log('Avg closed per person calculation:', totalClosed, '/', people.length, '=', avgClosedPerPerson);
    
    // Calculate open tickets and aging metrics early (exclude State = "Blocked" since we use DEBLOCKED column)
    const openUniqueTickets = pbisUnique.filter(row => {
        const state = row['State'] || '';
        return state !== 'Done' && state !== 'Removed' && state !== 'Closed' && state.toLowerCase() !== 'blocked';
    });
    
    // Calculate age for each open unique ticket
    const openUniqueTicketsWithAge = openUniqueTickets.map(row => {
        // Use Start Date if available, otherwise fall back to State Change Date, then Created Date
        let startDate = row['Start Date'] || row['State Change Date'] || row['Created Date'];
        
        const developmentStartDate = parseDate(startDate);
        const ageInDays = developmentStartDate ? Math.round((today - developmentStartDate) / (1000 * 60 * 60 * 24)) : 0;
        return {
            ...row,
            ageInDays: Math.max(0, ageInDays), // Ensure non-negative age
            developmentStartDate: startDate
        };
    }).filter(ticket => ticket.ageInDays >= 0); // Only valid ages
    
    // Tickets closed per person
    const closedByPerson = {};
    closedTickets.forEach(row => {
        const person = row['Assigned To'];
        closedByPerson[person] = (closedByPerson[person] || 0) + 1;
    });
    // Tickets closed over time (monthly, quarterly, annual) - exclude future dates
    const closedByMonthRaw = closedTickets.map(row => {
        const closedDate = parseDate(row['Closed Date']);
        return {
            key: `${closedDate.getFullYear()}-${String(closedDate.getMonth()+1).padStart(2,'0')}`,
            date: closedDate
        };
    }).filter(item => item.date <= today); // Only include dates up to today
    
    // Debug monthly calculations
    console.log('=== MONTHLY CALCULATIONS DEBUG ===');
    console.log('Closed tickets for monthly calc:', closedTickets.length);
    console.log('Sample closed tickets:', closedTickets.slice(0, 3).map(row => ({
        id: row['Work Item Id'],
        closedDate: row['Closed Date'],
        state: row['State']
    })));
    
    // Sort months chronologically
    const monthKeys = [...new Set(closedByMonthRaw.map(x => x.key))];
    monthKeys.sort((a, b) => {
        const [ay, am] = a.split('-').map(Number);
        const [by, bm] = b.split('-').map(Number);
        return ay === by ? am - bm : ay - by;
    });
    
    const closedByMonth = {};
    monthKeys.forEach(key => {
        closedByMonth[key] = closedTickets.filter(row => {
            const closedDate = parseDate(row['Closed Date']);
            return closedDate <= today && `${closedDate.getFullYear()}-${String(closedDate.getMonth()+1).padStart(2,'0')}` === key;
        });
    });
    
    // Debug each month's count
    console.log('Monthly breakdown:');
    monthKeys.forEach(key => {
        console.log(`${key}: ${closedByMonth[key].length} PBI's`);
        if (closedByMonth[key].length > 0) {
            console.log('  Sample work items:', closedByMonth[key].slice(0, 3).map(row => row['Work Item Id']));
        }
    });
    
    const closedByQuarter = groupBy(closedTickets, row => parseQuarter(row['Closed Date']));
    const closedByYear = groupBy(closedTickets, row => {
        const closedDate = parseDate(row['Closed Date']);
        return closedDate.getFullYear();
    });
    // Ticket state pie using unique work items
    const stateCounts = {};
    uniqueData.forEach(row => {
        const state = row['State'] || 'Unknown';
        stateCounts[state] = (stateCounts[state] || 0) + 1;
    });
    // Ticket type pie using unique work items
    const typeCounts = {};
    uniqueData.forEach(row => {
        const type = row['Work Item Type'] || 'Unknown';
        typeCounts[type] = (typeCounts[type] || 0) + 1;
    });
    // Average time to close tickets by developer (from development start to Done state)
    console.log('=== STARTING AVERAGE TIME CALCULATION ===');
    const avgTimeStats = {};
    const doneTicketsForCalc = uniqueData.filter(row => row['State'] === 'Done');
    console.log('Done tickets for calculation:', doneTicketsForCalc.length);
    
    doneTicketsForCalc.forEach((row, index) => {
        const person = row['Assigned To'];
        const startDate = row['Start Date'] || row['State Change Date'] || row['Created Date'];
        const closedDate = row['Closed Date'] || row['State Change Date'];
        
        console.log(`\n--- Processing ticket ${index + 1} for ${person} ---`);
        console.log('Available date fields:', {
            'Start Date': row['Start Date'],
            'Closed Date': row['Closed Date'],
            'State Change Date': row['State Change Date'],
            'Created Date': row['Created Date']
        });
        console.log('Using dates:', { startDate, closedDate });
        
        if (startDate && closedDate) {
            const days = daysBetween(startDate, closedDate);
            console.log(`Days result for ${person}:`, days);
            
            if (days !== null && days >= 0) {
                if (!avgTimeStats[person]) avgTimeStats[person] = { totalDays: 0, count: 0 };
                avgTimeStats[person].totalDays += days;
                avgTimeStats[person].count += 1;
                console.log(`Updated stats for ${person}:`, avgTimeStats[person]);
            } else {
                console.log(`Invalid days result for ${person}:`, days);
            }
        } else {
            console.log(`Missing dates for ${person}`);
        }
    });
    
    console.log('Final avgTimeStats:', avgTimeStats);
    const avgTimeRows = Object.entries(avgTimeStats).map(([person, stats]) => ({
        developer: person,
        avgDays: stats.count ? (stats.totalDays / stats.count).toFixed(2) : 'N/A',
        count: stats.count
    })).sort((a, b) => {
        // Sort by average days (ascending), treating 'N/A' as infinity
        const aAvg = a.avgDays === 'N/A' ? Infinity : parseFloat(a.avgDays);
        const bAvg = b.avgDays === 'N/A' ? Infinity : parseFloat(b.avgDays);
        return aAvg - bAvg;
    });
    
    // Median time to close tickets by developer (development cycle time)
    function median(arr) {
        arr = arr.filter(x => typeof x === 'number' && !isNaN(x) && x >= 0);
        if (arr.length === 0) return 'N/A';
        arr.sort((a,b) => a-b);
        const mid = Math.floor(arr.length/2);
        return arr.length % 2 ? arr[mid] : ((arr[mid-1]+arr[mid])/2).toFixed(2);
    }
    console.log('=== STARTING MEDIAN TIME CALCULATION ===');
    const medianTimeStats = {};
    doneTicketsForCalc.forEach((row, index) => {
        const person = row['Assigned To'];
        const startDate = row['Start Date'] || row['State Change Date'] || row['Created Date'];
        const closedDate = row['Closed Date'] || row['State Change Date'];
        
        if (startDate && closedDate) {
            const days = daysBetween(startDate, closedDate);
            
            if (days !== null && days >= 0) {
                if (!medianTimeStats[person]) medianTimeStats[person] = [];
                medianTimeStats[person].push(days);
                console.log(`Added ${days} days for ${person}. Array now:`, medianTimeStats[person]);
            }
        }
    });
    
    console.log('Final medianTimeStats:', medianTimeStats);
    const medianTimeRows = Object.entries(medianTimeStats).map(([person, arr]) => ({
        developer: person,
        medianDays: arr.length ? median(arr) : 'N/A',
        count: arr.length
    })).sort((a, b) => {
        // Sort by median days (ascending), treating 'N/A' as infinity
        const aMedian = a.medianDays === 'N/A' ? Infinity : parseFloat(a.medianDays);
        const bMedian = b.medianDays === 'N/A' ? Infinity : parseFloat(b.medianDays);
        return aMedian - bMedian;
    });
    
    // ===== TICKET AGING ANALYSIS =====
    
    // Filter open tickets (not Done/Closed)
    const openTickets = data.filter(row => {
        const state = row['State'] || '';
        return state !== 'Done' && state !== 'Closed' && state !== 'Resolved' && state !== '';
    });
    
    // Calculate age for open tickets based on development start date
    const openTicketsWithAge = openTickets.map(row => {
        // Use Start Date if available, otherwise fall back to State Change Date, then Created Date
        let startDate = row['Start Date'] || row['State Change Date'] || row['Created Date'];
        
        const developmentStartDate = parseDate(startDate);
        const ageInDays = developmentStartDate ? Math.round((today - developmentStartDate) / (1000 * 60 * 60 * 24)) : 0;
        return {
            ...row,
            ageInDays: Math.max(0, ageInDays), // Ensure non-negative age
            developmentStartDate: startDate
        };
    }).filter(ticket => ticket.ageInDays >= 0); // Only valid ages
    
    // Update KPIs with aging metrics using unique work items
    const openTicketsCount = openUniqueTickets.length;
    const avgAgeAllOpen = openUniqueTicketsWithAge.length > 0 ? 
        (openUniqueTicketsWithAge.reduce((sum, ticket) => sum + ticket.ageInDays, 0) / openUniqueTicketsWithAge.length).toFixed(1) : 0;

    // Debug open tickets calculations
    console.log('=== OPEN TICKETS DEBUG ===');
    console.log('Open unique tickets count:', openTicketsCount);
    console.log('Open tickets with age count:', openUniqueTicketsWithAge.length);
    console.log('Sample open tickets with age:', openUniqueTicketsWithAge.slice(0, 3));
    console.log('Average age calculation result:', avgAgeAllOpen);
    
    document.getElementById('kpiSection').innerHTML = `
        <div class="col-md-2 kpi">Total PBI's: ${totalTickets}</div>
        <div class="col-md-2 kpi">PBI's Closed: ${totalClosed}</div>
        <div class="col-md-2 kpi">Open PBI's: ${openTicketsCount}</div>
        <div class="col-md-3 kpi">Avg Age (Open): ${avgAgeAllOpen} days</div>
        <div class="col-md-3 kpi">Avg Closed/Person: ${avgClosedPerPerson}</div>
    `;
    
    // Calculate and display blocked items summary (exclude State = "Blocked" since we use DEBLOCKED column)
    const filteredDataForSummary = uniqueData.filter(row => {
        const state = row['State'] || '';
        return state.toLowerCase() !== 'blocked'; // Exclude items with State = "Blocked"
    });
    
    const totalBlockedItems = filteredDataForSummary.filter(row => {
        const deblocked = row['DEBLOCKED'];
        return (deblocked === 'TRUE' || deblocked === true || deblocked === 'True');
    });
    
    if (totalBlockedItems.length > 0) {
        const blockedPercentage = ((totalBlockedItems.length / filteredDataForSummary.length) * 100).toFixed(1);
        
        // Calculate average age of blocked items
        let totalBlockedAge = 0;
        let blockedItemsWithAge = 0;
        
        totalBlockedItems.forEach(item => {
            const createdDate = parseDate(item['Created Date']);
            if (createdDate) {
                const ageInDays = Math.floor((today - createdDate) / (1000 * 60 * 60 * 24));
                totalBlockedAge += ageInDays;
                blockedItemsWithAge++;
            }
        });
        
        const avgBlockedAge = blockedItemsWithAge > 0 ? (totalBlockedAge / blockedItemsWithAge).toFixed(1) : 0;
        
        // Group blocked items by state
        const blockedByStateForSummary = {};
        totalBlockedItems.forEach(item => {
            const state = item['State'] || 'Unknown';
            if (!blockedByStateForSummary[state]) {
                blockedByStateForSummary[state] = 0;
            }
            blockedByStateForSummary[state]++;
        });
        
        // Show the blocked summary section
        document.getElementById('blockedSummarySection').style.display = 'block';
        document.getElementById('blockedSummaryContent').innerHTML = `
            <div class="col-md-3">
                <strong>Total Blocked:</strong><br>
                <span class="text-danger" style="font-size: 1.5rem;">${totalBlockedItems.length}</span>
                <small class="d-block text-muted">(${blockedPercentage}% of all PBI's)</small>
            </div>
            <div class="col-md-3">
                <strong>Avg Blocked Age:</strong><br>
                <span class="text-warning" style="font-size: 1.5rem;">${avgBlockedAge}</span>
                <small class="d-block text-muted">days</small>
            </div>
            <div class="col-md-6">
                <strong>Blocked by State:</strong><br>
                ${Object.entries(blockedByStateForSummary)
                    .sort((a, b) => b[1] - a[1])
                    .map(([state, count]) => `<span class="badge bg-warning text-dark me-1">${state}: ${count}</span>`)
                    .join(' ')}
            </div>
        `;
    } else {
        // Hide the blocked summary section if no blocked items
        document.getElementById('blockedSummarySection').style.display = 'none';
    }
    // Tickets per person chart
    const tppCtx = document.getElementById('ticketsPerPersonChart').getContext('2d');
    new Chart(tppCtx, {
        type: 'bar',
        data: {
            labels: Object.keys(closedByPerson),
            datasets: [{
                label: 'PBI\'s Closed',
                data: Object.values(closedByPerson),
                backgroundColor: 'rgba(54, 162, 235, 0.6)'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
            interaction: { intersect: false, mode: 'nearest' },
            plugins: {
                legend: { display: false },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: safe(function(context) { return context[0].label; }, ''),
                        label: safe(function(context) { return `PBI's Closed: ${context.parsed.y}`; }, '')
                    }
                }
            },
            scales: {
                x: { ticks: { autoSkip: true, maxRotation: 30 } },
                y: { beginAtZero: true }
            }
        }
    });
    // Tickets over time chart (monthly, ordered)
    const totCtx = document.getElementById('ticketsOverTimeChart').getContext('2d');
    new Chart(totCtx, {
        type: 'line',
        data: {
            labels: monthKeys,
            datasets: [{
                label: 'PBI\'s Closed (Monthly)',
                data: monthKeys.map(key => closedByMonth[key].length),
                borderColor: 'rgba(255,99,132,1)',
                backgroundColor: 'rgba(255,99,132,0.2)',
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
            interaction: { intersect: false, mode: 'nearest' },
            plugins: {
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: safe(function(context) { return context[0].label; }, ''),
                        label: safe(function(context) { return `PBI's Closed: ${context.parsed.y}`; }, '')
                    }
                }
            }
        }
    });
    
    // Inflow vs Outflow Chart - Calculate opened and closed tickets per month
    const inflowData = {}; // Tickets opened per month
    const outflowData = {}; // Tickets closed per month
    
    // Calculate inflow (tickets created/opened per month)
    pbisUnique.forEach(row => {
        const createdDate = parseDate(row['Created Date']);
        if (createdDate && createdDate <= new Date()) {
            const monthKey = `${createdDate.getFullYear()}-${String(createdDate.getMonth() + 1).padStart(2, '0')}`;
            inflowData[monthKey] = (inflowData[monthKey] || 0) + 1;
        }
    });
    
    // Calculate outflow (tickets closed per month) 
    closedTickets.forEach(row => {
        const closedDate = parseDate(row['Closed Date']);
        if (closedDate && closedDate <= new Date()) {
            const monthKey = `${closedDate.getFullYear()}-${String(closedDate.getMonth() + 1).padStart(2, '0')}`;
            outflowData[monthKey] = (outflowData[monthKey] || 0) + 1;
        }
    });
    
    // Create combined month keys for both inflow and outflow
    const allMonthKeys = [...new Set([...Object.keys(inflowData), ...Object.keys(outflowData)])].sort();
    
    const inflowOutflowCtx = document.getElementById('inflowOutflowChart').getContext('2d');
    new Chart(inflowOutflowCtx, {
        type: 'line',
        data: {
            labels: allMonthKeys,
            datasets: [
                {
                    label: 'Inflow (PBI\'s Opened)',
                    data: allMonthKeys.map(key => inflowData[key] || 0),
                    borderColor: '#3498DB',
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 5,
                    pointHoverRadius: 8,
                    pointBackgroundColor: '#3498DB',
                    pointBorderColor: '#FFFFFF',
                    pointBorderWidth: 2
                },
                {
                    label: 'Outflow (PBI\'s Closed)',
                    data: allMonthKeys.map(key => outflowData[key] || 0),
                    borderColor: '#27AE60',
                    backgroundColor: 'rgba(39, 174, 96, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 5,
                    pointHoverRadius: 8,
                    pointBackgroundColor: '#27AE60',
                    pointBorderColor: '#FFFFFF',
                    pointBorderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Monthly Ticket Flow Trends',
                    font: { size: 16, weight: 'bold' },
                    color: '#2C3E50'
                },
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        font: { size: 12 },
                        color: '#2C3E50'
                    }
                },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: safe(function(context) {
                            return `Month: ${context[0].label}`;
                        }, ''),
                        label: safe(function(context) {
                            const datasetLabel = context.dataset.label;
                            const value = context.parsed.y;
                            return `${datasetLabel}: ${value} tickets`;
                        }, ''),
                        afterBody: safe(function(context) {
                            const monthKey = context[0].label;
                            const inflow = inflowData[monthKey] || 0;
                            const outflow = outflowData[monthKey] || 0;
                            const netFlow = inflow - outflow;
                            const netLabel = netFlow > 0 ? 'Net Increase' : netFlow < 0 ? 'Net Decrease' : 'Net Neutral';
                            return [`Net Flow: ${netFlow} tickets (${netLabel})`];
                        }, [])
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Month',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    grid: {
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Number of Tickets',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                }
            }
        }
    });
    
    // Monthly Developer Performance Heatmap
    const monthlyDeveloperData = {};
    const developerSet = new Set();
    const monthSet = new Set();
    
    // Process closed tickets to create monthly developer matrix
    closedTickets.forEach(row => {
        const closedDate = parseDate(row['Closed Date']);
        const developer = row['Assigned To'] || 'Unassigned';
        
        if (closedDate && developer) {
            const monthKey = `${closedDate.toLocaleString('default', { month: 'long' })} ${closedDate.getFullYear()}`;
            
            // Initialize data structure
            if (!monthlyDeveloperData[monthKey]) {
                monthlyDeveloperData[monthKey] = {};
            }
            if (!monthlyDeveloperData[monthKey][developer]) {
                monthlyDeveloperData[monthKey][developer] = 0;
            }
            
            monthlyDeveloperData[monthKey][developer] += 1;
            developerSet.add(developer);
            monthSet.add(monthKey);
        }
    });
    
    // Sort months chronologically
    const sortedMonths = Array.from(monthSet).sort((a, b) => {
        const dateA = new Date(a);
        const dateB = new Date(b);
        return dateA - dateB;
    });
    
    const sortedDevelopers = Array.from(developerSet).sort();
    
    console.log('Debug Heatmap Data:');
    console.log('Sorted Months:', sortedMonths);
    console.log('Sorted Developers:', sortedDevelopers);
    console.log('Monthly Developer Data:', monthlyDeveloperData);
    
    // Create heatmap data structure for Chart.js
    const heatmapData = [];
    
    // Calculate min and max values for dynamic color scaling
    const allValues = Object.values(monthlyDeveloperData).flatMap(month => 
        Object.values(month)
    ).filter(val => val > 0); // Exclude zeros from min/max calculation
    
    const maxValue = allValues.length > 0 ? Math.max(...allValues) : 0;
    const minValue = allValues.length > 0 ? Math.min(...allValues) : 0;
    
    console.log(`Heatmap value range: min=${minValue}, max=${maxValue}`);
    console.log('Sample values for color scaling:', allValues.slice(0, 10));
    
    sortedMonths.forEach((month, monthIndex) => {
        sortedDevelopers.forEach((developer, devIndex) => {
            const value = monthlyDeveloperData[month] && monthlyDeveloperData[month][developer] ? 
                monthlyDeveloperData[month][developer] : 0;
            
            heatmapData.push({
                x: devIndex,   // Developer index on X-axis
                y: monthIndex, // Month index on Y-axis
                v: value
            });
        });
    });
    
    console.log('Heatmap Data Points:', heatmapData);
    console.log('Max Value:', maxValue);
    
    // Create custom heatmap using scatter plot with sized points
    const developerHeatmapCtx = document.getElementById('developerHeatmapChart').getContext('2d');

    // Measure longest month label to compute dynamic right padding and avoid crossing with axis title
    developerHeatmapCtx.save();
    developerHeatmapCtx.font = 'bold 13px Arial';
    const maxMonthLabelWidth = sortedMonths.length
        ? Math.max(...sortedMonths.map(m => developerHeatmapCtx.measureText(String(m)).width))
        : 0;
    developerHeatmapCtx.restore();
    const rightLabelOffset = 12; // space from chart area to month labels
    const titleGap = 24;         // gap between month labels and rotated axis title
    const monthsTitleOffset = rightLabelOffset + maxMonthLabelWidth + titleGap; // used by plugin
    const dynamicRightPadding = Math.ceil(monthsTitleOffset + 40); // ensure title has breathing room

    // Function to get color based on value using dynamic heat mapping
    function getHeatmapColor(value, maxValue, minValue) {
        if (value === 0) return 'rgba(255, 152, 0, 0.8)'; // Orange for zero (no white)
        
        // Calculate the range and position within that range
        const range = maxValue - minValue;
        if (range === 0) {
            // All values are the same, use medium green
            return 'rgba(76, 175, 80, 0.8)';
        }
        
        // For value = 1, always use yellow
        if (value === 1) {
            return 'rgba(255, 235, 59, 0.9)'; // Yellow for 1
        }
        
        // For value = 2, always use light green
        if (value === 2) {
            return 'rgba(139, 195, 74, 0.8)'; // Light green for 2
        }
        
        // For values > 2, use dynamic scaling
        if (value > 2) {
            // Normalize value to 0-1 scale within the range above 2
            const adjustedMin = Math.max(3, minValue);
            const adjustedRange = maxValue - adjustedMin;
            
            if (adjustedRange <= 0) {
                return 'rgba(76, 175, 80, 0.9)'; // Medium green if all values are 2 or below
            }
            
            const normalizedValue = (value - adjustedMin) / adjustedRange;
            
            // Create heat map colors from medium to dark green for values > 2
            if (normalizedValue >= 0.7) {
                // Top 30% - Dark green
                return 'rgba(27, 94, 32, 1.0)';
            } else if (normalizedValue >= 0.4) {
                // 40-70% - Medium-dark green
                return 'rgba(46, 125, 50, 0.9)';
            } else {
                // Bottom 40% of values > 2 - Medium green
                return 'rgba(76, 175, 80, 0.8)';
            }
        }
        
        // Fallback (shouldn't reach here)
        return 'rgba(76, 175, 80, 0.8)';
    }
    
    new Chart(developerHeatmapCtx, {
        type: 'scatter',
        data: {
            datasets: [{
                label: 'PBI\'s Closed',
                data: heatmapData.map(point => ({
                    x: point.x,
                    y: point.y,
                    value: point.v
                })),
                backgroundColor: heatmapData.map(point => getHeatmapColor(point.v, maxValue, minValue)),
                borderColor: '#FFFFFF',
                borderWidth: 1,
                pointStyle: 'rect',
                // Keep a tiny point for tooltip anchoring; plugin draws the full cell
                pointRadius: 2,
                pointHoverRadius: 2,
                pointHitRadius: 28
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
            interaction: { intersect: false, mode: 'nearest' },
            hover: { mode: 'nearest', intersect: false, animationDuration: 0 },
            layout: {
                // Right padding is dynamic to prevent the rotated 'Months' title from overlapping month labels
                padding: { left: 80, right: dynamicRightPadding, top: 60, bottom: 160 }
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Monthly PBI Closure Heatmap by Developer',
                    font: { size: 16, weight: 'bold' },
                    color: '#2C3E50',
                    padding: { top: 8, bottom: 12 }
                },
                legend: { display: false },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: function(context) {
                            const point = context[0];
                            const devIndex = Math.round(point.parsed.x);
                            const monthIndex = Math.round(point.parsed.y);
                            const month = sortedMonths[monthIndex] || 'Unknown';
                            const developer = sortedDevelopers[devIndex] || 'Unknown';
                            return `${developer} - ${month}`;
                        },
                        label: function(context) {
                            return `PBI's Closed: ${context.raw.value}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'linear',
                    position: 'top',
                    min: -0.5,
                    max: sortedDevelopers.length - 0.5,
                    title: {
                        display: false,
                        text: 'Developers',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    ticks: {
                        display: false,
                        stepSize: 1,
                        align: 'center',
                        crossAlign: 'center',
                        callback: function(value) {
                            const devIndex = Math.round(value);
                            const fullName = sortedDevelopers[devIndex];
                            return fullName ? fullName.split(' ')[0] : '';
                        },
                        maxRotation: 0,
                        font: { size: 14, weight: 'bold' },
                        padding: 16
                    },
                    grid: { display: false }
                },
                y: {
                    type: 'linear',
                    min: -0.5,
                    max: sortedMonths.length - 0.5,
                    title: {
                        display: false,
                        text: 'Months',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    ticks: {
                        display: false,
                        stepSize: 1,
                        align: 'center',
                        crossAlign: 'center',
                        callback: function(value) {
                            const monthIndex = Math.round(value);
                            const label = sortedMonths[monthIndex];
                            // Show short month and year
                            return label ? label : '';
                        },
                        font: { size: 13, weight: 'bold' },
                        padding: 12
                    },
                    grid: { display: false }
                }
            }
        },
        plugins: [
            // Draw full cell rectangles behind points to fill gaps
            {
                id: 'heatmapCells',
                beforeDatasetsDraw(chart) {
                    const { ctx, scales, chartArea } = chart;
                    const xScale = scales.x;
                    const yScale = scales.y;
                    const meta = chart.getDatasetMeta(0);
                    ctx.save();
                    // Clip to chart area to avoid drawing outside axes
                    ctx.beginPath();
                    ctx.rect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                    ctx.clip();
                    heatmapData.forEach((point, index) => {
                        const element = meta.data[index];
                        if (!element) return;
                        // Compute pixel bounds for the cell (x=developer index, y=month index)
                        const xPix1 = xScale.getPixelForValue(point.x - 0.5);
                        const xPix2 = xScale.getPixelForValue(point.x + 0.5);
                        const yPix1 = yScale.getPixelForValue(point.y - 0.5);
                        const yPix2 = yScale.getPixelForValue(point.y + 0.5);
                        const left = Math.min(xPix1, xPix2);
                        const right = Math.max(xPix1, xPix2);
                        const top = Math.min(yPix1, yPix2);
                        const bottom = Math.max(yPix1, yPix2);
                        const width = right - left;
                        const height = bottom - top;
                        if (width <= 0 || height <= 0) return;
                        // Fill the entire cell (touching edges) for a fully colored heatmap
                        ctx.fillStyle = getHeatmapColor(point.v, maxValue, minValue);
                        ctx.fillRect(left, top, width, height);
                    });
                    ctx.restore();
                }
            },
            // Draw centered developer labels (bottom) and month labels (right)
            {
                id: 'heatmapAxisLabels',
                afterDatasetsDraw(chart) {
                    const { ctx, chartArea, scales } = chart;
                    const xScale = scales.x;
                    const yScale = scales.y;
                    ctx.save();
                    // Developers on bottom, centered per column
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#2C3E50';
                    for (let i = 0; i < sortedDevelopers.length; i++) {
                        const x = xScale.getPixelForValue(i);
                        const name = (sortedDevelopers[i] || '').split(' ')[0] || '';
                        ctx.fillText(name, x, chartArea.bottom + 8);
                    }
                    // Months on right, centered per row
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.font = 'bold 13px Arial';
                    for (let j = 0; j < sortedMonths.length; j++) {
                        const y = yScale.getPixelForValue(j);
                        const label = sortedMonths[j] || '';
                        // Draw month labels with a fixed offset from the chart area
                        ctx.fillText(label, chartArea.right + rightLabelOffset, y);
                    }
                    // Custom axis titles
                    // Bottom title (Developers)
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('Developers', chartArea.left + chartArea.width / 2, chartArea.bottom + 40);
                    // Right title (Months)
                    ctx.save();
                    // Place rotated title to the right of the longest month label to avoid crossing
                    ctx.translate(chartArea.right + monthsTitleOffset, chartArea.top + chartArea.height / 2);
                    ctx.rotate(Math.PI / 2);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Months', 0, 0);
                    ctx.restore();
                    ctx.restore();
                }
            },
            // Draw count labels on top of the cell color
            {
                id: 'heatmapPointLabels',
                afterDatasetsDraw(chart) {
                    const { ctx } = chart;
                    const meta = chart.getDatasetMeta(0);
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = 'bold 15px Arial';
                    heatmapData.forEach((point, index) => {
                        const element = meta.data[index];
                        if (!element) return;
                        const { x, y } = element;
                        const value = point.v;
                        let color = '#000';
                        if (value === 0) color = '#000';
                        else if (value >= 7) color = '#fff';
                        ctx.fillStyle = color;
                        ctx.fillText(String(value), x, y);
                    });
                    ctx.restore();
                }
            }
        ]
    });
    
    // Add a dynamic legend/scale for the heatmap
    const heatmapLegendHtml = `
        <div style="margin-top: 10px; text-align: center;">
            <strong>Heat Map Scale (PBI Count):</strong>
            <span style="display: inline-block; margin: 0 10px;">
                <span style="background: rgba(255, 152, 0, 0.8); padding: 8px 12px; margin: 2px; border: 1px solid #cc8400; color: #000; font-weight: bold;">0</span>
                <span style="background: rgba(255, 235, 59, 0.9); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #000; font-weight: bold;">1</span>
                <span style="background: rgba(139, 195, 74, 0.8); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #000; font-weight: bold;">2</span>
                <span style="background: rgba(76, 175, 80, 0.8); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #000; font-weight: bold;">3-${Math.round(maxValue * 0.7)}</span>
                <span style="background: rgba(46, 125, 50, 0.9); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #fff; font-weight: bold;">${Math.round(maxValue * 0.7) + 1}-${Math.round(maxValue * 0.9)}</span>
                <span style="background: rgba(27, 94, 32, 1.0); padding: 8px 12px; margin: 2px; border: 1px solid #ccc; color: #fff; font-weight: bold;">${Math.round(maxValue * 0.9) + 1}+</span>
            </span>
        </div>
    `;
    
    // Insert legend after the chart
    document.getElementById('developerHeatmapChart').parentNode.insertAdjacentHTML('afterend', heatmapLegendHtml);
    
    // Quarterly Closed PBI's & Average State Duration Analysis
    const quarterlyClosedData = {};
    
    // First, let's group data by Work Item Id to calculate actual blocked days
    const workItemHistory = {};
    data.forEach(row => {
        const workItemId = row['Work Item Id'];
        if (!workItemHistory[workItemId]) {
            workItemHistory[workItemId] = [];
        }
        workItemHistory[workItemId].push(row);
    });
    
    // Process closed tickets to calculate quarterly data with actual blocked time
    closedTickets.forEach(row => {
        const closedDate = parseDate(row['Closed Date']);
        const createdDate = parseDate(row['Created Date']);
        const workItemId = row['Work Item Id'];
        
        if (closedDate && createdDate && workItemHistory[workItemId]) {
            // Calculate quarter key
            const year = closedDate.getFullYear();
            const quarter = Math.ceil((closedDate.getMonth() + 1) / 3);
            const quarterKey = `${year}-Q${quarter}`;
            
            // Initialize quarter data if not exists
            if (!quarterlyClosedData[quarterKey]) {
                quarterlyClosedData[quarterKey] = {
                    totalClosed: 0,
                    statesDuration: {},
                    totalDurationAcrossStates: 0,
                    pbiCount: 0,
                    blockedInfo: { totalBlockedDays: 0, blockedCount: 0 }
                };
            }
            
            // Calculate total time from creation to closure
            const totalDays = Math.max(0, Math.floor((closedDate - createdDate) / (1000 * 60 * 60 * 24)));
            
            // Calculate ACTUAL blocked days from the history
            const workItemHistoryData = workItemHistory[workItemId];
            let actualBlockedDays = 0;
            let wasEverBlocked = false;
            
            // Count consecutive days where DEBLOCKED = TRUE
            const sortedHistory = workItemHistoryData.sort((a, b) => {
                const dateA = parseDate(a['Date']);
                const dateB = parseDate(b['Date']);
                return dateA - dateB;
            });
            
            sortedHistory.forEach(historyRow => {
                const isBlocked = historyRow['DEBLOCKED'] && 
                                 historyRow['DEBLOCKED'].toString().toUpperCase() === 'TRUE';
                if (isBlocked) {
                    actualBlockedDays++;
                    wasEverBlocked = true;
                }
            });
            
            // Get current state for estimation purposes
            const currentState = row['State'] || 'Unknown';
            
            // Calculate estimated state durations using actual blocked time
            const estimatedStateDurations = calculateEstimatedStateDurationsWithActualBlocking(
                totalDays, currentState, actualBlockedDays, wasEverBlocked
            );
            
            // Add to quarterly data
            quarterlyClosedData[quarterKey].totalClosed += 1;
            quarterlyClosedData[quarterKey].totalDurationAcrossStates += totalDays;
            quarterlyClosedData[quarterKey].pbiCount += 1;
            
            // Track actual blocked information
            if (wasEverBlocked && actualBlockedDays > 0) {
                quarterlyClosedData[quarterKey].blockedInfo.totalBlockedDays += actualBlockedDays;
                quarterlyClosedData[quarterKey].blockedInfo.blockedCount += 1;
                
                // Add actual blocked state to estimations
                estimatedStateDurations['Blocked'] = actualBlockedDays;
            }
            
            // Aggregate state durations
            Object.entries(estimatedStateDurations).forEach(([state, duration]) => {
                if (!quarterlyClosedData[quarterKey].statesDuration[state]) {
                    quarterlyClosedData[quarterKey].statesDuration[state] = { totalDays: 0, count: 0 };
                }
                quarterlyClosedData[quarterKey].statesDuration[state].totalDays += duration;
                quarterlyClosedData[quarterKey].statesDuration[state].count += 1;
            });
        }
    });
    
    // Helper function to estimate state durations using actual blocked time from DEBLOCKED column
    function calculateEstimatedStateDurationsWithActualBlocking(totalDays, finalState, actualBlockedDays, wasEverBlocked = false) {
        const durations = {};
        
        if (totalDays <= 0) return durations;
        
        // Use actual blocked days from the data
        let availableDays = totalDays;
        if (wasEverBlocked && actualBlockedDays > 0) {
            // Ensure blocked days don't exceed total days
            const blockedDays = Math.min(actualBlockedDays, totalDays);
            availableDays = totalDays - blockedDays;
            durations['Blocked'] = blockedDays;
        }
        
        // Apply pattern based on final state for remaining time
        if (finalState.toLowerCase().includes('done') || finalState.toLowerCase().includes('completed')) {
            durations['New'] = Math.round(availableDays * 0.10);
            durations['Analysis'] = Math.round(availableDays * 0.15);
            durations['Development'] = Math.round(availableDays * 0.50);
            durations['Review'] = Math.round(availableDays * 0.15);
            durations['Done'] = Math.round(availableDays * 0.10);
        } else {
            // For other states, distribute more evenly
            durations[finalState] = Math.round(availableDays * 0.70);
            durations['New'] = Math.round(availableDays * 0.15);
            durations['Analysis'] = Math.round(availableDays * 0.15);
        }
        
        return durations;
    }
    
    // Original helper function to estimate state durations (since we don't have transition history)
    function calculateEstimatedStateDurations(totalDays, finalState, isBlocked = false) {
        // Enhanced estimation model that considers blocking impact
        const durations = {};
        
        if (totalDays <= 0) return durations;
        
        // Calculate blocked time more intelligently based on final state
        let availableDays = totalDays;
        let blockedDays = 0;
        
        if (isBlocked) {
            // State-specific blocked time estimation
            switch(finalState.toLowerCase()) {
                case 'development':
                case 'in progress':
                    // Development blocks tend to be longer (25-50% of total time)
                    blockedDays = Math.round(totalDays * (0.25 + Math.random() * 0.25));
                    break;
                case 'analysis':
                case 'review':
                    // Analysis/review blocks are typically shorter (15-35% of total time)
                    blockedDays = Math.round(totalDays * (0.15 + Math.random() * 0.20));
                    break;
                case 'test':
                case 'testing':
                    // Testing blocks are moderate (20-40% of total time)
                    blockedDays = Math.round(totalDays * (0.20 + Math.random() * 0.20));
                    break;
                case 'done':
                case 'completed':
                    // If it's done but was blocked, assume blocking happened earlier
                    // Distribute blocked time across the development phase
                    blockedDays = Math.round(totalDays * 0.30);
                    break;
                default:
                    // Default estimation (20-40% of time was spent blocked)
                    blockedDays = Math.round(totalDays * (0.20 + Math.random() * 0.20));
            }
            
            // Ensure blocked days don't exceed 80% of total time
            blockedDays = Math.min(blockedDays, Math.round(totalDays * 0.8));
            availableDays = totalDays - blockedDays;
            durations['Blocked'] = blockedDays;
        }
        
        // Apply pattern based on final state for remaining time
        if (finalState.toLowerCase().includes('done') || finalState.toLowerCase().includes('completed')) {
            durations['New'] = Math.round(availableDays * 0.10);
            durations['Analysis'] = Math.round(availableDays * 0.15);
            durations['Development'] = Math.round(availableDays * 0.50);
            durations['Review'] = Math.round(availableDays * 0.15);
            durations['Done'] = Math.round(availableDays * 0.10);
        } else {
            // For other states, distribute more evenly
            durations[finalState] = Math.round(availableDays * 0.70);
            durations['New'] = Math.round(availableDays * 0.15);
            durations['Analysis'] = Math.round(availableDays * 0.15);
        }
        
        return durations;
    }
    
    // Get all quarters and states for the chart
    const allQuarterKeys = Object.keys(quarterlyClosedData).sort();
    const allStatesInClosed = new Set();
    
    // Collect all states from the quarterly data
    Object.values(quarterlyClosedData).forEach(qData => {
        Object.keys(qData.statesDuration).forEach(state => allStatesInClosed.add(state));
    });
    const quarterlyUniqueStates = Array.from(allStatesInClosed);
    
    // Create datasets for closed count (bars)
    const closedCountDataset = {
        label: 'PBI\'s Closed',
        type: 'bar',
        data: allQuarterKeys.map(quarter => quarterlyClosedData[quarter].totalClosed),
        // Much lighter fill to reduce intensity
        backgroundColor: 'rgba(52, 152, 219, 0.15)',
        borderColor: 'rgba(52, 152, 219, 0.0)',
        borderWidth: 0,
        barPercentage: 0.8,
        categoryPercentage: 0.8,
        // Draw behind lines and start hidden (user can toggle from legend)
        order: 1,
        hidden: true,
        yAxisID: 'y'
    };
    
    // Create datasets for average state durations (lines)
    const stateDurationDatasets = quarterlyUniqueStates.map((state, index) => {
        // Special handling for blocked state - make it red and more prominent
        let color, borderWidth, pointRadius;
        
        if (state.toLowerCase() === 'blocked') {
            color = '#E74C3C'; // Red for blocked
            borderWidth = 4;    // Thicker line
            pointRadius = 8;    // Larger points
        } else {
            const colors = ['#27AE60', '#F39C12', '#9B59B6', '#1ABC9C', '#34495E', '#E67E22', '#3498DB'];
            color = colors[index % colors.length];
            borderWidth = 3;
            pointRadius = 6;
        }
        
        return {
            label: `Avg Days in ${state}`,
            type: 'line',
            data: allQuarterKeys.map(quarter => {
                const qData = quarterlyClosedData[quarter];
                const stateData = qData.statesDuration[state];
                return stateData ? (stateData.totalDays / stateData.count).toFixed(1) : 0;
            }),
            borderColor: color,
            backgroundColor: color + '20',
            borderWidth: borderWidth,
            pointRadius: pointRadius,
            pointHoverRadius: pointRadius + 2,
            pointBackgroundColor: color,
            pointBorderColor: '#FFFFFF',
            pointBorderWidth: 2,
            // Ensure lines draw above the (very light) bars
            order: 2,
            yAxisID: 'y1',
            tension: 0.4
        };
    });
    
    const quarterlyClosedCtx = document.getElementById('quarterlyClosedChart').getContext('2d');
    new Chart(quarterlyClosedCtx, {
        type: 'bar',
        data: {
            labels: allQuarterKeys,
            datasets: [closedCountDataset, ...stateDurationDatasets]
        },
        options: {
            responsive: true,
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Quarterly Analysis: Closed PBI\'s Count & Average State Duration (Red Line = Actual Blocked Days)',
                    font: { size: 16, weight: 'bold' },
                    color: '#2C3E50'
                },
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        font: { size: 11 },
                        color: '#2C3E50'
                    }
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            const quarter = context[0].label;
                            const qData = quarterlyClosedData[quarter];
                            return [`Quarter: ${quarter}`, `Total Closed: ${qData ? qData.totalClosed : 0} PBI's`];
                        },
                        label: function(context) {
                            const datasetLabel = context.dataset.label;
                            const value = context.parsed.y;
                            
                            if (datasetLabel.includes('Closed')) {
                                return `${datasetLabel}: ${value} PBI's`;
                            } else {
                                return `${datasetLabel}: ${value} days`;
                            }
                        },
                        afterBody: function(context) {
                            const quarter = context[0].label;
                            const qData = quarterlyClosedData[quarter];
                            if (qData) {
                                const avgTotalDuration = qData.pbiCount > 0 ? 
                                    (qData.totalDurationAcrossStates / qData.pbiCount).toFixed(1) : 0;
                                
                                let result = [`Overall Avg Duration: ${avgTotalDuration} days`];
                                
                                // Add actual blocked state information if available
                                if (qData.blockedInfo.blockedCount > 0) {
                                    const avgActualBlockedDays = (qData.blockedInfo.totalBlockedDays / qData.blockedInfo.blockedCount).toFixed(1);
                                    const blockedPercentage = ((qData.blockedInfo.blockedCount / qData.totalClosed) * 100).toFixed(1);
                                    result.push(`Blocked PBI's: ${qData.blockedInfo.blockedCount} (${blockedPercentage}%)`);
                                    result.push(`Actual Avg Blocked Days: ${avgActualBlockedDays} days`);
                                    result.push(`(Based on DEBLOCKED=TRUE entries)`);
                                }
                                
                                return result;
                            }
                            return [];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Quarter',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    grid: {
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: {
                        display: true,
                        text: 'Number of PBI\'s Closed',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: {
                        display: true,
                        text: 'Average Days in State',
                        font: { size: 14, weight: 'bold' },
                        color: '#2C3E50'
                    },
                    beginAtZero: true,
                    grid: {
                        drawOnChartArea: false,
                        color: 'rgba(44, 62, 80, 0.1)'
                    }
                }
            }
        }
    });
    
    // Features Created per Quarter (based on Created Date)
    const allFeatures = uniqueData.filter(row => (row['Work Item Type'] || '').toLowerCase() === 'feature');
    const featuresByQuarter = groupBy(allFeatures, row => parseQuarter(row['Created Date']));
    const featureQuarterKeys = Object.keys(featuresByQuarter).filter(k => k && k !== 'QNaN undefined').sort((a, b) => {
        // Sort by year then quarter
        const [qa, ya] = a.split(' '); // e.g., 'Q3 2025'
        const [qb, yb] = b.split(' ');
        const ia = parseInt(ya, 10), ib = parseInt(yb, 10);
        const qaNum = parseInt(qa.replace('Q',''), 10), qbNum = parseInt(qb.replace('Q',''), 10);
        return ia === ib ? qaNum - qbNum : ia - ib;
    });
    
    const featuresPerQuarterCtx = document.getElementById('featuresPerQuarterChart').getContext('2d');
    new Chart(featuresPerQuarterCtx, {
        type: 'bar',
        data: {
            labels: featureQuarterKeys,
            datasets: [{
                label: 'Features Created',
                data: featureQuarterKeys.map(k => (featuresByQuarter[k] || []).length),
                backgroundColor: 'rgba(52, 152, 219, 0.7)',
                borderColor: '#3498DB',
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Features Created per Quarter (by Created Date)',
                    font: { size: 16, weight: 'bold' },
                    color: '#2C3E50'
                },
                legend: { display: false },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: function(context) { return `Quarter: ${context[0].label}`; },
                        label: function(context) { return `Features: ${context.parsed.y}`; }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Quarter', font: { size: 14, weight: 'bold' } },
                    grid: { display: false }
                },
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Count', font: { size: 14, weight: 'bold' } }
                }
            }
        }
    });
    
    // Populate Features table (basic details, most recent first by Created Date)
    const parseDateSafe = (d) => {
        if (!d) return null;
        const clean = String(d).split(' ')[0];
        const parts = clean.split('/');
        if (parts.length === 3) return new Date(parts[2], parts[0]-1, parts[1]);
        const dt = new Date(clean);
        return isNaN(dt) ? null : dt;
    };
    const featuresSorted = allFeatures
        .map(f => ({
            id: f['Work Item Id'] || f['ID'] || '',
            title: f['Title'] || '',
            created: f['Created Date'] || '',
            state: f['State'] || 'Unknown',
            assignee: f['Assigned To'] || 'Unassigned',
            sortDate: parseDateSafe(f['Created Date']) || new Date(0)
        }))
        .sort((a, b) => b.sortDate - a.sortDate);
    const featuresTbody = document.querySelector('#featuresTable tbody');
    featuresTbody.innerHTML = featuresSorted.map(f => `
        <tr>
            <td>${f.id}</td>
            <td title="${f.title}">${f.title.substring(0, 100)}${f.title.length > 100 ? 'â€¦' : ''}</td>
            <td>${f.created ? String(f.created).split(' ')[0] : ''}</td>
            <td><span class="badge ${f.state === 'Done' ? 'bg-success' : 'bg-secondary'}">${f.state}</span></td>
            <td>${f.assignee}</td>
        </tr>
    `).join('');
    
    // Ticket state pie chart with semantic colors
    const tspCtx = document.getElementById('ticketStatePieChart').getContext('2d');
    
    // Create color mapping based on state names
    const stateLabels = Object.keys(stateCounts);
    const pieStateColors = stateLabels.map(state => {
        const lowerState = state.toLowerCase();
        if (lowerState.includes('done') || lowerState.includes('completed') || lowerState.includes('closed')) {
            return '#27AE60'; // Green for completed states
        } else if (lowerState.includes('blocked')) {
            return '#E74C3C'; // Red for blocked states
        } else if (lowerState.includes('progress') || lowerState.includes('development') || lowerState.includes('active')) {
            return '#3498DB'; // Blue for active work
        } else if (lowerState.includes('review') || lowerState.includes('testing') || lowerState.includes('test')) {
            return '#9B59B6'; // Purple for review/testing
        } else if (lowerState.includes('analysis') || lowerState.includes('planning')) {
            return '#F39C12'; // Orange for analysis/planning
        } else if (lowerState.includes('new') || lowerState.includes('open') || lowerState.includes('todo')) {
            return '#95A5A6'; // Gray for new/open items
        } else {
            return '#34495E'; // Dark gray for unknown states
        }
    });
    
    console.log('State color mapping:', stateLabels.map((label, i) => ({ state: label, color: pieStateColors[i] })));
    
    new Chart(tspCtx, {
        type: 'pie',
        data: {
            labels: stateLabels,
            datasets: [{
                data: Object.values(stateCounts),
                backgroundColor: pieStateColors,
                borderColor: '#FFFFFF',
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        usePointStyle: true,
                        generateLabels: function(chart) {
                            const data = chart.data;
                            return data.labels.map((label, i) => ({
                                text: `${label} (${data.datasets[0].data[i]})`,
                                fillStyle: data.datasets[0].backgroundColor[i],
                                strokeStyle: data.datasets[0].borderColor,
                                lineWidth: data.datasets[0].borderWidth,
                                pointStyle: 'circle'
                            }));
                        }
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const label = context.label || '';
                            const value = context.parsed;
                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                            const percentage = ((value / total) * 100).toFixed(1);
                            return `${label}: ${value} tickets (${percentage}%)`;
                        }
                    }
                }
            }
        }
    });
    // Ticket type pie chart
    const ttpCtx = document.getElementById('ticketTypePieChart').getContext('2d');
    new Chart(ttpCtx, {
        type: 'pie',
        data: {
            labels: Object.keys(typeCounts),
            datasets: [{
                data: Object.values(typeCounts),
                backgroundColor: ['#6610f2','#e83e8c','#fd7e14','#20c997','#6f42c1','#343a40']
            }]
        },
        options: {responsive:true}
    });
    
    // Continue with other existing functionality...
    
    // Blocked state analysis using unique work items (exclude State = "Blocked" since we use DEBLOCKED column)
    const blockedCounts = {};
    const blockedByState = {}; // Track which states have blocked items
    
    const filteredUniqueData = uniqueData.filter(row => {
        const state = row['State'] || '';
        return state.toLowerCase() !== 'blocked'; // Exclude items with State = "Blocked"
    });
    
    filteredUniqueData.forEach(row => {
        const deblocked = row['DEBLOCKED'];
        const currentState = row['State'] || 'Unknown';
        
        // DEBLOCKED = TRUE means the item IS currently blocked
        // DEBLOCKED = FALSE means the item is NOT blocked
        const isBlocked = (deblocked === 'TRUE' || deblocked === true || deblocked === 'True');
        const blockedStatus = isBlocked ? 'Blocked' : 'Not Blocked';
        
        blockedCounts[blockedStatus] = (blockedCounts[blockedStatus] || 0) + 1;
        
        // Track blocked items by state
        if (isBlocked) {
            if (!blockedByState[currentState]) {
                blockedByState[currentState] = { count: 0, totalAge: 0 };
            }
            blockedByState[currentState].count += 1;
            
            // Calculate age for blocked items
            const createdDate = parseDate(row['Created Date']);
            if (createdDate) {
                const ageInDays = Math.floor((today - createdDate) / (1000 * 60 * 60 * 24));
                blockedByState[currentState].totalAge += ageInDays;
            }
        }
    });
    
    const blockedRows = Object.entries(blockedCounts).map(([status, count]) => ({
        status: status,
        count: count,
        percentage: ((count / filteredUniqueData.length) * 100).toFixed(1)
    }));
    
    // Add blocked by state information to the blocked table
    const blockedByStateRows = Object.entries(blockedByState).map(([state, data]) => ({
        status: `${state} (Blocked)`,
        count: data.count,
        percentage: ((data.count / uniqueData.length) * 100).toFixed(1),
        avgAge: data.count > 0 ? (data.totalAge / data.count).toFixed(1) : '0'
    }));
    
    const blockedBody = document.querySelector('#blockedStateTable tbody');
    
    // Combine overall blocked counts with state-specific blocked information
    const allBlockedRows = [
        ...blockedRows,
        ...blockedByStateRows
    ];
    
    blockedBody.innerHTML = allBlockedRows.map(row => {
        const isStateSpecific = row.status.includes('(Blocked)');
        const rowClass = isStateSpecific ? 'table-warning' : '';
        const avgAgeColumn = row.avgAge ? `<td>${row.avgAge} days</td>` : '<td>-</td>';
        
        return `<tr class="${rowClass}">
            <td>${row.status}</td>
            <td>${row.count}</td>
            <td>${row.percentage}%</td>
            ${avgAgeColumn}
        </tr>`;
    }).join('');
    
    // Feature details table - showing implemented and in progress features ONLY (no Product Backlog Items) using unique work items
    const featureDetails = uniqueData.filter(row => {
        const workItemType = row['Work Item Type'] || '';
        const status = row['State'] || '';
        // Include ONLY Features that are Done or In Progress
        return workItemType === 'Feature' && 
               (status === 'Done' || status === 'In Progress' || status === 'Development' || status === 'Analysis' || status === 'Review' || status === 'Test');
    }).map(row => ({
        id: row['Work Item Id'] || 'N/A',
        title: (row['Title'] || 'No Title').substring(0, 100) + ((row['Title'] || '').length > 100 ? '...' : ''), // Slightly longer titles since we removed a column
        status: row['State'] || 'Unknown',
        developer: row['Assigned To'] || 'Unassigned',
        createdDate: row['Created Date'] ? row['Created Date'].split(' ')[0] : 'N/A' // Just the date part
    })).sort((a, b) => {
        // Sort by status (Done first, then others), then by developer
        if (a.status === 'Done' && b.status !== 'Done') return -1;
        if (a.status !== 'Done' && b.status === 'Done') return 1;
        return a.developer.localeCompare(b.developer);
    });
    
    const featureDetailsBody = document.querySelector('#featureDetailsTable tbody');
    featureDetailsBody.innerHTML = featureDetails.map(row => {
        const statusClass = row.status === 'Done' ? 'text-success' : 'text-warning';
        return `<tr>
            <td>${row.id}</td>
            <td title="${row.title}">${row.title}</td>
            <td><span class="${statusClass}">${row.status}</span></td>
            <td>${row.developer}</td>
            <td>${row.createdDate}</td>
        </tr>`;
    }).join('');
    // Tickets closed by type using unique work items
    const ticketsByType = {};
    uniqueData.filter(row => row['State'] === 'Done').forEach(row => {
        const type = row['Work Item Type'] || 'Unknown';
        ticketsByType[type] = (ticketsByType[type] || 0) + 1;
    });
    
    // Age distribution histogram for open tickets using unique work items
    // (openUniqueTickets and openUniqueTicketsWithAge already calculated above)
    const ageBins = [0, 7, 14, 30, 60, 90, 180, 365];
    const ageHistCounts = Array(ageBins.length).fill(0);
    const ages = openUniqueTicketsWithAge.map(ticket => ticket.ageInDays);
    
    ages.forEach(age => {
        for (let i = 0; i < ageBins.length; i++) {
            if (age <= ageBins[i]) { 
                ageHistCounts[i]++; 
                break; 
            }
        }
    });
    
    const ageHistLabels = ageBins.map((bin, i) => i === 0 ? `â‰¤${bin} days` : `${ageBins[i-1]+1}-${bin} days`);
    
    const ageHistCtx = document.getElementById('ticketAgeHistogram').getContext('2d');
    new Chart(ageHistCtx, {
        type: 'bar',
        data: {
            labels: ageHistLabels,
            datasets: [{
                label: 'Open Tickets',
                data: ageHistCounts,
                backgroundColor: 'rgba(255, 159, 64, 0.6)',
                borderColor: 'rgba(255, 159, 64, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            }
        }
    });
    
    // Average age by state for open tickets using unique work items
    const ageByState = {};
    openUniqueTicketsWithAge.forEach(ticket => {
        const state = ticket['State'] || 'Unknown';
        if (!ageByState[state]) {
            ageByState[state] = { totalAge: 0, count: 0 };
        }
        ageByState[state].totalAge += ticket.ageInDays;
        ageByState[state].count += 1;
    });
    
    const ageByStateData = Object.entries(ageByState).map(([state, stats]) => ({
        state: state,
        avgAge: stats.count > 0 ? (stats.totalAge / stats.count).toFixed(1) : 0,
        count: stats.count
    })).sort((a, b) => parseFloat(b.avgAge) - parseFloat(a.avgAge));
    
    const ageByStateCtx = document.getElementById('ageByStateChart').getContext('2d');
    new Chart(ageByStateCtx, {
        type: 'bar',
        data: {
            labels: ageByStateData.map(item => `${item.state} (${item.count})`),
            datasets: [{
                label: 'Average Age (Days)',
                data: ageByStateData.map(item => parseFloat(item.avgAge)),
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
    
    // Aging Scatter Chart - State vs Age with blocked highlighting (Product Backlog Items only)
    const scatterData = [];
    const statePositions = {}; // Map states to x-axis positions
    
    // Filter for Product Backlog Items only, excluding items with State = "Blocked"
    // (We use DEBLOCKED column for blocking representation instead)
    const productBacklogItems = openUniqueTicketsWithAge.filter(ticket => {
        const workItemType = ticket['Work Item Type'] || '';
        const state = ticket['State'] || '';
        return workItemType === 'Product Backlog Item' && state.toLowerCase() !== 'blocked';
    });
    
    const uniqueStates = [...new Set(productBacklogItems.map(ticket => ticket['State'] || 'Unknown'))].sort();
    
    // Assign x-axis positions to states
    uniqueStates.forEach((state, index) => {
        statePositions[state] = index;
    });
    
    // Enhanced state colors for scatter plot (Blocked is NOT a state - it's a condition)
    const scatterStateColors = {
        'In Progress': '#3498db',
        'Development': '#e74c3c', 
        'Analysis': '#f39c12',
        'Review': '#2ecc71',
        'Test': '#9b59b6',
        'New': '#95a5a6',
        'Unknown': '#34495e'
    };
    
    // Simplified function to get color - only two colors: default blue and red for blocked
    function getScatterColor(ticket) {
        const isBlocked = (ticket['DEBLOCKED'] === true) || (String(ticket['DEBLOCKED']).toLowerCase() === 'true');

        if (isBlocked) {
            return '#E74C3C'; // Red for blocked items
        }

        return '#3498DB'; // Default blue for all non-blocked items
    }
    
    // Prepare scatter plot data (Product Backlog Items only)
    productBacklogItems.forEach(ticket => {
        const state = ticket['State'] || 'Unknown';
        const age = ticket.ageInDays;
        const isBlocked = ticket['DEBLOCKED'] === 'TRUE' || ticket['DEBLOCKED'] === true || ticket['DEBLOCKED'] === 'True';
        
        scatterData.push({
            x: statePositions[state],
            y: age,
            ticket: ticket,
            isBlocked: isBlocked,
            color: getScatterColor(ticket)
        });
    });
    
    // Group data by color for proper rendering - simplified to just two categories
    const scatterDatasets = {};
    scatterData.forEach(point => {
        const color = point.color;
        if (!scatterDatasets[color]) {
            scatterDatasets[color] = {
                label: point.isBlocked ? 'Blocked Items' : 'Regular Items',
                data: [],
                backgroundColor: color,
                borderColor: color,
                pointRadius: point.isBlocked ? 8 : 6,
                pointHoverRadius: point.isBlocked ? 10 : 8,
                showLine: false
            };
        }
        scatterDatasets[color].data.push(point);
    });
    
    const agingScatterCtx = document.getElementById('agingScatterChart').getContext('2d');
    
    // Calculate overall health score based on blocked vs non-blocked items
    const totalItems = productBacklogItems.length;
    let healthScore = 0;
    
    if (totalItems > 0) {
        const blockedTickets = productBacklogItems.filter(ticket => {
            return (ticket['DEBLOCKED'] === true) || (String(ticket['DEBLOCKED']).toLowerCase() === 'true');
        }).length;
        const nonBlockedTickets = totalItems - blockedTickets;
        
        // Calculate health score (0-100): Non-blocked = good, Blocked = bad
        healthScore = (nonBlockedTickets * 100) / totalItems;
        
        console.log(`Health Analysis: ${nonBlockedTickets} non-blocked, ${blockedTickets} blocked tickets. Health Score: ${healthScore.toFixed(1)}`);
    }
    
    // Determine background color based on health score
    let backgroundColor;
    if (healthScore >= 75) {
        backgroundColor = 'rgba(39, 174, 96, 0.15)'; // Strong green background - healthy situation
    } else if (healthScore >= 50) {
        backgroundColor = 'rgba(46, 204, 113, 0.12)'; // Light green background - mostly healthy
    } else if (healthScore >= 35) {
        backgroundColor = 'rgba(241, 196, 15, 0.12)'; // Yellow background - mixed situation
    } else if (healthScore >= 20) {
        backgroundColor = 'rgba(243, 156, 18, 0.15)'; // Orange background - concerning
    } else {
        backgroundColor = 'rgba(231, 76, 60, 0.15)'; // Red background - critical situation
    }
    
    // Set the canvas background color
    agingScatterCtx.canvas.style.backgroundColor = backgroundColor;
    
    new Chart(agingScatterCtx, {
        type: 'scatter',
        data: {
            datasets: Object.values(scatterDatasets)
        },
        options: {
            responsive: true,
            scales: {
                x: {
                    type: 'linear',
                    position: 'bottom',
                    min: -0.5,
                    max: uniqueStates.length - 0.5,
                    ticks: {
                        stepSize: 1,
                        callback: function(value) {
                            return uniqueStates[Math.round(value)] || '';
                        }
                    },
                    title: {
                        display: true,
                        text: 'Ticket State',
                        font: { size: 14, weight: 'bold' }
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Age (Days)',
                        font: { size: 14, weight: 'bold' }
                    },
                    grid: {
                        color: function(context) {
                            // Safe access to tick value
                            const value = context?.tick?.value;
                            if (typeof value !== 'number') return 'rgba(0, 0, 0, 0.1)';
                            
                            // Enhanced grid lines at age thresholds
                            if (value === 25) {
                                return 'rgba(39, 174, 96, 0.6)'; // Green line at 25 days
                            }
                            if (value === 60) {
                                return 'rgba(243, 156, 18, 0.6)'; // Orange line at 60 days
                            }
                            if ([90, 120].includes(value)) {
                                return 'rgba(231, 76, 60, 0.5)'; // Red lines at high age thresholds
                            }
                            // Subtle gradient for other grid lines
                            if (value <= 25) {
                                return 'rgba(39, 174, 96, 0.2)'; // Light green grid for recent zone
                            } else if (value <= 60) {
                                return 'rgba(243, 156, 18, 0.2)'; // Light orange grid for moderate zone
                            } else {
                                return 'rgba(231, 76, 60, 0.2)'; // Light red grid for old zone
                            }
                        },
                        lineWidth: function(context) {
                            // Safe access to tick value
                            const value = context?.tick?.value;
                            if (typeof value !== 'number') return 1;
                            
                            // Thicker lines at key thresholds
                            if ([25, 60].includes(value)) {
                                return 2;
                            }
                            return 1;
                        }
                    },
                    ticks: {
                        color: function(context) {
                            // Safe access to tick value
                            const value = context?.tick?.value;
                            if (typeof value !== 'number') return '#000000';
                            
                            // Color-code the age labels
                            if (value <= 25) {
                                return '#27AE60'; // Green for recent
                            } else if (value <= 60) {
                                return '#F39C12'; // Orange for moderate
                            } else {
                                return '#E74C3C'; // Red for old
                            }
                        },
                        font: {
                            weight: function(context) {
                                // Safe access to tick value
                                const value = context?.tick?.value;
                                if (typeof value !== 'number') return 'normal';
                                
                                // Bold font for key thresholds
                                if ([25, 60].includes(value)) {
                                    return 'bold';
                                }
                                return 'normal';
                            }
                        }
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        filter: function(legendItem) {
                            // Show Blocked and all non-blocked age bands
                            return legendItem.text.includes('Blocked') || 
                                   legendItem.text.includes('â‰¤25 days') || 
                                   legendItem.text.includes('26-60 days') ||
                                   legendItem.text.includes('>60 days');
                        }
                    }
                },
                tooltip: {
                    callbacks: {
                        title: function(tooltipItems) {
                            const point = tooltipItems[0];
                            const ticket = scatterData.find(d => d.x === point.parsed.x && d.y === point.parsed.y);
                            return ticket ? `ID: ${ticket.ticket['Work Item Id'] || 'N/A'}` : '';
                        },
                        label: function(context) {
                            const point = scatterData.find(d => d.x === context.parsed.x && d.y === context.parsed.y);
                            if (!point) return '';
                            
                            const ticket = point.ticket;
                            const title = ticket['Title'] ? ticket['Title'].substring(0, 50) + '...' : 'No Title';
                            const state = ticket['State'] || 'Unknown';
                            const developer = ticket['Assigned To'] || 'Unassigned';
                            const age = ticket.ageInDays;
                            const blockedStatus = point.isBlocked ? ' (BLOCKED)' : '';
                            
                            return [
                                `Title: ${title}`,
                                `State: ${state}${blockedStatus}`,
                                `Developer: ${developer}`,
                                `Age: ${age} days`,
                                `Start Date: ${ticket.developmentStartDate || 'N/A'}`
                            ];
                        }
                    }
                }
            },
            layout: {
                padding: 20
            }
        }
    });
    
    // Update health indicator display
    const healthIndicator = document.getElementById('healthIndicator');
    if (totalItems > 0) {
        const blockedTickets = productBacklogItems.filter(ticket => 
            ticket['DEBLOCKED'] === 'TRUE' || ticket['DEBLOCKED'] === true || ticket['DEBLOCKED'] === 'True'
        ).length;
        const nonBlockedTickets = totalItems - blockedTickets;
        
        let healthMessage, healthClass, borderColor;
        
        if (healthScore >= 90) {
            healthMessage = `ðŸŸ¢ EXCELLENT Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-success';
            borderColor = '#27AE60';
        } else if (healthScore >= 75) {
            healthMessage = `ðŸŸ¡ GOOD Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-info';
            borderColor = '#2ECC71';
        } else if (healthScore >= 50) {
            healthMessage = `ðŸŸ  MODERATE Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-warning';
            borderColor = '#F1C40F';
        } else if (healthScore >= 25) {
            healthMessage = `ðŸŸ  CONCERNING Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-warning';
            borderColor = '#F39C12';
        } else {
            healthMessage = `ðŸ”´ CRITICAL Health (${healthScore.toFixed(1)}%)`;
            healthClass = 'alert-danger';
            borderColor = '#E74C3C';
        }
        
        healthIndicator.className = `alert ${healthClass}`;
        healthIndicator.style.borderLeftColor = borderColor;
        healthIndicator.innerHTML = `
            <strong>${healthMessage}</strong><br>
            <small>
                ðŸ“Š Status Distribution: 
                <span class="badge bg-primary">${nonBlockedTickets} Regular Items</span>
                <span class="badge bg-danger">${blockedTickets} Blocked Items</span>
                | <strong>Total: ${totalItems} Product Backlog Items</strong>
            </small>
        `;
    } else {
        healthIndicator.className = 'alert alert-secondary';
        healthIndicator.innerHTML = '<strong>No Product Backlog Items found</strong>';
    }
    
    // Aging Distribution Matrix - Shows states vs age ranges in matrix format
    const agingMatrixData = {};
    const stateColors = {
        'In Progress': '#3498db',
        'Development': '#e74c3c', 
        'Analysis': '#f39c12',
        'Review': '#2ecc71',
        'Test': '#9b59b6',
        'Blocked': '#e67e22',
        'New': '#95a5a6',
        'Unknown': '#34495e'
    };
    
    // Get all unique states from open tickets using unique work items
    const allStates = [...new Set(openUniqueTicketsWithAge.map(ticket => ticket['State'] || 'Unknown'))].sort();
    
    // Initialize matrix data structure
    allStates.forEach(state => {
        agingMatrixData[state] = {};
        ageHistLabels.forEach(ageRange => {
            agingMatrixData[state][ageRange] = 0;
        });
    });
    
    // Count tickets for each state-age combination using unique work items
    openUniqueTicketsWithAge.forEach(ticket => {
        const state = ticket['State'] || 'Unknown';
        const age = ticket.ageInDays;
        
        // Find which age range this ticket belongs to
        let ageRange = ageHistLabels[ageHistLabels.length - 1]; // default to last range
        for (let i = 0; i < ageBins.length; i++) {
            if (age <= ageBins[i]) {
                ageRange = ageHistLabels[i];
                break;
            }
        }
        
        agingMatrixData[state][ageRange]++;
    });
    
    // Create datasets for matrix chart (each state is a separate dataset)
    const matrixDatasets = allStates.map((state, index) => ({
        label: state,
        data: ageHistLabels.map(ageRange => ({
            x: ageRange,
            y: state,
            v: agingMatrixData[state][ageRange]
        })),
        backgroundColor: stateColors[state] || '#7f8c8d',
        borderColor: stateColors[state] || '#7f8c8d',
        borderWidth: 1,
        barThickness: 40,
        categoryPercentage: 0.8,
        barPercentage: 0.9
    }));
    
    const agingByStateCtx = document.getElementById('agingByStateChart').getContext('2d');
    new Chart(agingByStateCtx, {
        type: 'bar',
        data: {
            labels: ageHistLabels,
            datasets: allStates.map(state => ({
                label: state,
                data: ageHistLabels.map(ageRange => agingMatrixData[state][ageRange]),
                backgroundColor: stateColors[state] || '#7f8c8d',
                borderColor: stateColors[state] || '#7f8c8d',
                borderWidth: 2,
                stack: 'matrix'
            }))
        },
        options: {
            responsive: true,
            indexAxis: 'y', // This makes it horizontal - states on Y-axis, age ranges as data
            scales: {
                x: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Number of Tickets',
                        font: { size: 14, weight: 'bold' }
                    },
                    grid: { display: true, color: 'rgba(0,0,0,0.1)' }
                },
                y: {
                    title: {
                        display: true,
                        text: 'States',
                        font: { size: 14, weight: 'bold' }
                    },
                    grid: { display: false }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'right',
                    labels: { 
                        usePointStyle: true,
                        font: { size: 12 }
                    }
                },
                tooltip: {
                    mode: 'nearest',
                    intersect: false,
                    callbacks: {
                        title: function(tooltipItems) {
                            const item = tooltipItems[0];
                            return `State: ${item.dataset.label}`;
                        },
                        label: function(context) {
                            const ageRange = context.label;
                            const count = context.raw;
                            const state = context.dataset.label;
                            
                            // Calculate percentage of this state's tickets in this age range
                            const stateTotal = ageHistLabels.reduce((sum, range) => 
                                sum + agingMatrixData[state][range], 0);
                            const percentage = stateTotal > 0 ? ((count / stateTotal) * 100).toFixed(1) : 0;
                            
                            return `${ageRange}: ${count} tickets (${percentage}% of ${state})`;
                        },
                        footer: function(tooltipItems) {
                            const item = tooltipItems[0];
                            const ageRange = item.label;
                            const totalInRange = allStates.reduce((sum, state) => 
                                sum + agingMatrixData[state][ageRange], 0);
                            return `Total in ${ageRange}: ${totalInRange} tickets`;
                        }
                    }
                }
            },
            layout: {
                padding: { right: 20 }
            }
        }
    });
    
    // Oldest open tickets table using unique work items
    const oldestTickets = openUniqueTicketsWithAge
        .sort((a, b) => b.ageInDays - a.ageInDays)
        .slice(0, 20) // Top 20 oldest tickets
        .map(ticket => ({
            id: ticket['Work Item Id'] || ticket['ID'] || 'N/A',
            title: (ticket['Title'] || 'No Title').substring(0, 80) + ((ticket['Title'] || '').length > 80 ? '...' : ''),
            developer: ticket['Assigned To'] || 'Unassigned',
            state: ticket['State'] || 'Unknown',
            age: ticket.ageInDays,
            startDate: ticket.developmentStartDate ? ticket.developmentStartDate.split(' ')[0] : 'N/A'
        }));
    
    const agingTableBody = document.querySelector('#agingTicketsTable tbody');
    agingTableBody.innerHTML = oldestTickets.map(ticket => {
        let ageClass = 'text-success';
        if (ticket.age > 90) ageClass = 'text-danger';
        else if (ticket.age > 30) ageClass = 'text-warning';
        
        return `<tr>
            <td>${ticket.id}</td>
            <td title="${ticket.title}">${ticket.title}</td>
            <td>${ticket.developer}</td>
            <td><span class="badge bg-secondary">${ticket.state}</span></td>
            <td><span class="${ageClass} fw-bold">${ticket.age}</span></td>
            <td>${ticket.startDate}</td>
        </tr>`;
    }).join('');
    
    // Developer Completion Time Analysis Table
    console.log('=== DEVELOPER COMPLETION ANALYSIS DEBUG ===');
    console.log('Total unique PBIs:', pbisUnique.length);
    
    // Check all possible "Done" state variations - ONLY show completed tickets
    const completedStates = [...new Set(pbisUnique.map(row => row['State']))];
    console.log('All states found:', completedStates);
    
    // Only include completed/done tickets
    const donePBIs = pbisUnique.filter(row => {
        const state = (row['State'] || '').toLowerCase();
        return state === 'done' || state === 'closed' || state === 'completed' || state === 'resolved';
    });
    console.log('Done/Closed/Completed PBIs count:', donePBIs.length);
    
    if (donePBIs.length > 0) {
        console.log('Sample done PBI fields:', Object.keys(donePBIs[0]));
        console.log('Sample done PBI data:', donePBIs[0]);
    }
    
    const completedPBIs = donePBIs.map((row, index) => {
        console.log(`\n--- Processing DONE PBI ${index + 1} ---`);
        console.log('Full row data:', row);
        
        // List all date-related fields in the row
        const dateFields = Object.keys(row).filter(key => 
            key.toLowerCase().includes('date') || 
            key.toLowerCase().includes('start') || 
            key.toLowerCase().includes('close') || 
            key.toLowerCase().includes('end')
        );
        console.log('Available date fields:', dateFields);
        dateFields.forEach(field => {
            console.log(`  ${field}: "${row[field]}"`);
        });
        
        // Get DEBLOCKED status - check multiple possible values
        const deblockedField = row['DEBLOCKED'] || row['Deblocked'] || row['deblocked'];
        const isBlocked = deblockedField === true || deblockedField === 'TRUE' || 
                         deblockedField === 'True' || deblockedField === 'true' || 
                         deblockedField === 1 || deblockedField === '1';
        
        console.log(`DEBLOCKED field value: "${deblockedField}" -> isBlocked: ${isBlocked}`);
        
        // Check all possible date field names
        const startDate = row['Start Date'] || row['State Change Date'] || row['Created Date'] || 
                         row['StartDate'] || row['StateChangeDate'] || row['CreatedDate'];
        const closedDate = row['Closed Date'] || row['Resolved Date'] || row['State Change Date'] ||
                          row['ClosedDate'] || row['ResolvedDate'] || row['StateChangeDate'];
        
        console.log(`Dates found: Start="${startDate}", Closed="${closedDate}"`);
        
        let totalCalendarDays = null;
        let totalBusinessDays = null;
        let estimatedBlockedDays = 0;
        let netWorkDays = 0;
        
        if (startDate && closedDate) {
            console.log('Both dates found, calling date calculation functions...');
            console.log(`Input dates: start="${startDate}", closed="${closedDate}"`);
            
            // Debug the date parsing step by step
            console.log('=== Testing daysBetween function ===');
            totalCalendarDays = daysBetween(startDate, closedDate);
            console.log(`daysBetween("${startDate}", "${closedDate}") = ${totalCalendarDays}`);
            
            console.log('=== Testing businessDaysBetween function ===');
            totalBusinessDays = businessDaysBetween(startDate, closedDate);
            console.log(`businessDaysBetween("${startDate}", "${closedDate}") = ${totalBusinessDays}`);
            
            // Additional debugging: Try parsing dates manually
            console.log('=== Manual date parsing test ===');
            try {
                const testStart = new Date(startDate);
                const testEnd = new Date(closedDate);
                console.log(`Manual parsing: start=${testStart}, end=${testEnd}`);
                console.log(`Start valid: ${!isNaN(testStart)}, End valid: ${!isNaN(testEnd)}`);
                if (!isNaN(testStart) && !isNaN(testEnd)) {
                    const diffMs = testEnd - testStart;
                    const diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    console.log(`Manual calculation: ${diffDays} days`);
                }
            } catch (e) {
                console.log('Manual parsing error:', e);
            }
            
            // Calculate blocked time based on DEBLOCKED status
            if (isBlocked && totalCalendarDays > 0) {
                // If blocked, estimate 20-40% of time was blocked (using 30% average)
                estimatedBlockedDays = Math.round(totalCalendarDays * 0.3);
            }
            
            // Net work days = business days minus estimated blocked days
            if (totalBusinessDays !== null && totalBusinessDays >= 0) {
                netWorkDays = Math.max(0, totalBusinessDays - estimatedBlockedDays);
            }
            
            console.log(`Final: Blocked=${estimatedBlockedDays}, Net=${netWorkDays}`);
        } else {
            console.log('Missing start or end date');
        }
        
        return {
            id: row['Work Item Id'] || row['ID'] || row['Id'] || `Unknown-${index}`,
            title: (row['Title'] || 'No Title').substring(0, 40) + ((row['Title'] || '').length > 40 ? '...' : ''),
            developer: row['Assigned To'] || row['AssignedTo'] || 'Unassigned',
            state: row['State'] || 'Unknown',
            blockedStatus: isBlocked ? 'BLOCKED' : 'Not Blocked',
            startDate: startDate ? String(startDate).split(' ')[0] : 'N/A',
            closedDate: closedDate ? String(closedDate).split(' ')[0] : 'N/A',
            totalDays: totalCalendarDays || 0,
            businessDays: totalBusinessDays || 0,
            blockedDays: estimatedBlockedDays,
            netWorkDays: netWorkDays,
            isBlocked: isBlocked,
            deblockedRaw: deblockedField // Keep raw value for debugging
        };
    }).filter(pbi => {
        // Only include items where we successfully calculated some days
        const hasValidDays = (pbi.totalDays > 0) || (pbi.businessDays > 0);
        if (!hasValidDays) {
            console.log(`Filtering out PBI ${pbi.id}: totalDays=${pbi.totalDays}, businessDays=${pbi.businessDays}`);
        }
        return hasValidDays;
    });
    
    console.log('Final completed PBIs for table (after filtering):', completedPBIs.length);
    if (completedPBIs.length > 0) {
        console.log('Sample completed PBI:', completedPBIs[0]);
        // Sort by state, then by net work days descending
        completedPBIs.sort((a, b) => {
            if (a.state !== b.state) return a.state.localeCompare(b.state);
            return b.netWorkDays - a.netWorkDays;
        });
    }
    
    const completionTableBody = document.querySelector('#developerCompletionTable tbody');
    if (!completionTableBody) {
        console.error('Developer completion table body not found!');
        return;
    }
    
    if (completedPBIs.length === 0) {
        completionTableBody.innerHTML = '<tr><td colspan="11" class="text-center text-muted">No PBIs found for analysis</td></tr>';
        return;
    }
    
    completionTableBody.innerHTML = completedPBIs.map(pbi => {
        let workDaysClass = 'text-success';
        if (pbi.netWorkDays > 15) workDaysClass = 'text-danger';
        else if (pbi.netWorkDays > 8) workDaysClass = 'text-warning';
        
        let stateClass = 'bg-secondary';
        if (pbi.state.toLowerCase().includes('done') || pbi.state.toLowerCase().includes('closed')) {
            stateClass = 'bg-success';
        } else if (pbi.state.toLowerCase().includes('progress') || pbi.state.toLowerCase().includes('development')) {
            stateClass = 'bg-primary';
        }
        
        const blockedBadge = pbi.isBlocked ? 'bg-danger' : 'bg-success';
        
        return `<tr>
            <td>${pbi.id}</td>
            <td title="${pbi.title}">${pbi.title}</td>
            <td>${pbi.developer}</td>
            <td><span class="badge ${stateClass}">${pbi.state}</span></td>
            <td><span class="badge ${blockedBadge}">${pbi.blockedStatus}</span></td>
            <td>${pbi.startDate}</td>
            <td>${pbi.closedDate}</td>
            <td>${pbi.totalDays}</td>
            <td>${pbi.businessDays}</td>
            <td>${pbi.blockedDays}</td>
            <td><span class="${workDaysClass} fw-bold">${pbi.netWorkDays}</span></td>
        </tr>`;
    }).join('');
}
document.getElementById('csvFileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    // Show loading indicator
    document.getElementById('kpiSection').innerHTML = '<div class="col-12 text-center"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div><p>Processing CSV file...</p></div>';
    
    Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: function(results) {
            if (results.errors.length > 0) {
                console.error('CSV parsing errors:', results.errors);
                document.getElementById('kpiSection').innerHTML = '<div class="col-12 alert alert-danger">CSV parsing errors: ' + results.errors.map(e => e.message).join(', ') + '</div>';
                return;
            }
            
            if (results.data.length === 0) {
                document.getElementById('kpiSection').innerHTML = '<div class="col-12 alert alert-warning">No data found in CSV file</div>';
                return;
            }
            
            try {
                updateDashboard(results.data);
            } catch (error) {
                console.error('Error updating dashboard:', error);
                document.getElementById('kpiSection').innerHTML = '<div class="col-12 alert alert-danger">Error processing data: ' + error.message + '</div>';
            }
        },
        error: function(error) {
            console.error('Papa.parse error:', error);
            document.getElementById('kpiSection').innerHTML = '<div class="col-12 alert alert-danger">Error parsing CSV: ' + error.message + '</div>';
        }
    });
});
</script>
</body>
</html>

